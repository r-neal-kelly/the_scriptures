import*as Utils from"./utils.js";import*as Unicode from"./unicode.js";export const LZSS_FIRST_BAD_INDEX=Unicode.LEADING_SURROGATE.FIRST;export const LZSS_LAST_BAD_INDEX=Unicode.TRAILING_SURROGATE.LAST;export const LZSS_MAX_LENGTH=1114112;export class LZSS_Control_Tokens{constructor({GOOD:t=0,BAD_A:e=1,BAD_B:o=2,BAD_AB:n=3}={}){0,0,0,0,0,0,0,0,this.good=String.fromCodePoint(t),this.bad_a=String.fromCodePoint(e),this.bad_b=String.fromCodePoint(o),this.bad_ab=String.fromCodePoint(n);const s=this.GOOD()+this.BAD_A()+this.BAD_B()+this.BAD_AB();this.has_token_regex=new RegExp(`[${s}]`),Object.freeze(this)}GOOD(){return this.good}BAD_A(){return this.bad_a}BAD_B(){return this.bad_b}BAD_AB(){return this.bad_ab}Has_Token(t){return this.has_token_regex.test(t)}}export function LZSS_Compress(t,e=1024,o=new LZSS_Control_Tokens){0,0,0;const n=new class{constructor({text:t,max_memory_length:e}){this.text=t,this.text_index=0,this.memory="",this.max_memory_length=e}Initial_Matches(t){0;const e=[];let o=new Unicode.Iterator({text:this.memory});for(;!o.Is_At_End();o=o.Next())if(o.Point()===t){const n=o.Index();e.push([n,n+t.length])}return e}Matches(t,e,o){0;for(const[n,s]of t){const t=s-n,i=t+Unicode.First_Point(this.memory.slice(s)).length,r=n+i;i>t&&o.length>=i&&o.slice(0,i)===this.memory.slice(n,r)&&e.push([n,r])}}Move_Memory(t){for(;this.memory.length+t>this.max_memory_length;){const t=Unicode.First_Point(this.memory);this.text_index+=t.length,this.memory=this.memory.slice(t.length)}this.memory=this.text.slice(this.text_index,this.text_index+this.memory.length+t)}Create_Token(t,e){const n=t>=LZSS_FIRST_BAD_INDEX&&t<=LZSS_LAST_BAD_INDEX,s=e>=LZSS_FIRST_BAD_INDEX&&e<=LZSS_LAST_BAD_INDEX;return n&&s?o.BAD_AB()+String.fromCodePoint(t-LZSS_FIRST_BAD_INDEX)+String.fromCodePoint(e-LZSS_FIRST_BAD_INDEX):n?o.BAD_A()+String.fromCodePoint(t-LZSS_FIRST_BAD_INDEX)+String.fromCodePoint(e):s?o.BAD_B()+String.fromCodePoint(t)+String.fromCodePoint(e-LZSS_FIRST_BAD_INDEX):o.GOOD()+String.fromCodePoint(t)+String.fromCodePoint(e)}Token(t){0;const e=t.Point(),o=this.Initial_Matches(e);if(o.length>0){const n=t.Points();let s=[],i=o,r=s;for(;i.length>0;)r=s,s=i,i=r,i.splice(0,i.length),this.Matches(s,i,n);const _=s[s.length-1],S=_[1]-_[0],c=this.text_index+_[0],A=this.text_index+_[1],h=this.Create_Token(c,A);return h.length<S?(this.Move_Memory(S),[h,new Unicode.Iterator({text:t.Text(),index:t.Index()+S})]):(this.Move_Memory(e.length),[e,new Unicode.Iterator({text:t.Text(),index:t.Index()+e.length})])}return this.Move_Memory(e.length),[e,new Unicode.Iterator({text:t.Text(),index:t.Index()+e.length})]}}({text:t,max_memory_length:e});let s="",i=new Unicode.Iterator({text:t});for(;!i.Is_At_End();){const[t,e]=n.Token(i);s+=t,i=e}return s}export function LZSS_Decompress(t,e=new LZSS_Control_Tokens){let o="",n=new Unicode.Iterator({text:t});for(;!n.Is_At_End();)if(n.Point()===e.GOOD()){n=n.Next();const t=n.Point().codePointAt(0);n=n.Next();const e=n.Point().codePointAt(0);o+=o.slice(t,e),n=n.Next()}else if(n.Point()===e.BAD_A()){n=n.Next();const t=n.Point().codePointAt(0)+LZSS_FIRST_BAD_INDEX;n=n.Next();const e=n.Point().codePointAt(0);o+=o.slice(t,e),n=n.Next()}else if(n.Point()===e.BAD_B()){n=n.Next();const t=n.Point().codePointAt(0);n=n.Next();const e=n.Point().codePointAt(0)+LZSS_FIRST_BAD_INDEX;o+=o.slice(t,e),n=n.Next()}else if(n.Point()===e.BAD_AB()){n=n.Next();const t=n.Point().codePointAt(0)+LZSS_FIRST_BAD_INDEX;n=n.Next();const e=n.Point().codePointAt(0)+LZSS_FIRST_BAD_INDEX;o+=o.slice(t,e),n=n.Next()}else o+=n.Point(),n=n.Next();return o}export function JSON_String_Array_Compress(t){return t.replace(/","/g,"\0")}export function JSON_String_Array_Decompress(t){return t.replace(/\x00/g,'","')}