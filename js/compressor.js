import*as Utils from"./utils.js";import*as Unicode from"./unicode.js";export const LZSS_MAX_STRING_LENGTH=Unicode.POINT_COUNT*Unicode.POINT_COUNT+Unicode.POINT_COUNT;export const LZSS_MAX_MEMORY_LENGTH=Unicode.POINT_COUNT;export const LZSS_ESCAPE_INDEX=16;export const LZSS_ESCAPE_STRING=String.fromCodePoint(LZSS_ESCAPE_INDEX);export const LZSS_FIRST_SURROGATE_INDEX=Unicode.LEADING_SURROGATE.FIRST;export const LZSS_LAST_SURROGATE_INDEX=Unicode.TRAILING_SURROGATE.LAST;var LZSS_Flags;function LZSS_Create_Pair(e,t){0,0,0,0;const _=t>=LZSS_FIRST_SURROGATE_INDEX&&t<=LZSS_LAST_SURROGATE_INDEX;let n=0;return e>=LZSS_FIRST_SURROGATE_INDEX&&e<=LZSS_LAST_SURROGATE_INDEX&&(n|=LZSS_Flags.SURROGATE_A,e-=LZSS_FIRST_SURROGATE_INDEX),_&&(n|=LZSS_Flags.SURROGATE_B,t-=LZSS_FIRST_SURROGATE_INDEX),String.fromCodePoint(n)+String.fromCodePoint(e)+String.fromCodePoint(t)}function LZSS_Read_Pair(e){const t=e.Point().codePointAt(0);0;let _=(e=e.Next()).Point().codePointAt(0);t&LZSS_Flags.SURROGATE_A&&(_+=LZSS_FIRST_SURROGATE_INDEX);let n=(e=e.Next()).Point().codePointAt(0);return t&LZSS_Flags.SURROGATE_B&&(n+=LZSS_FIRST_SURROGATE_INDEX),[e=e.Next(),_,n]}function LZSS_Create_Header(e){let t="";0;return t+=LZSS_Create_Pair(Math.floor(e/LZSS_MAX_MEMORY_LENGTH),e%LZSS_MAX_MEMORY_LENGTH),0,t}function LZSS_Read_Header(e){let t,_;return[e,t,_]=LZSS_Read_Pair(e),[e,t*LZSS_MAX_MEMORY_LENGTH+_]}function LZSS_Create_Token(e,t){return 0,0,0,0,LZSS_Create_Pair(e-=1,t-=1)}function LZSS_Read_Token(e){let t,_;return[e,t,_]=LZSS_Read_Pair(e),t+=1,_+=1,[e,t,_]}!function(e){e[e.SURROGATE_A=1]="SURROGATE_A",e[e.SURROGATE_B=2]="SURROGATE_B",e[e.UNUSED_1=4]="UNUSED_1",e[e.UNUSED_2=8]="UNUSED_2"}(LZSS_Flags||(LZSS_Flags={}));class LZSS_Window{constructor({text:e,max_memory_length:t}){this.text=e,this.text_index=0,this.memory="",this.max_memory_length=t,this.matches_buffer_a=[],this.matches_buffer_b=[]}Initial_Matches(e,t){0,e.splice(0,e.length);let _=new Unicode.Iterator({text:this.memory});for(;!_.Is_At_End();_=_.Next())if(_.Point()===t){const n=_.Index();e.push([n,n+t.length])}}Matches(e,t,_){t.splice(0,t.length);for(const[n,o]of e){const e=o-n,s=e+Unicode.First_Point(this.memory.slice(o)).length,r=n+s;s>e&&_.length>=s&&_.slice(0,s)===this.memory.slice(n,r)&&t.push([n,r])}}Move_Memory(e){for(;this.memory.length+e>this.max_memory_length;){const e=Unicode.First_Point(this.memory);this.text_index+=e.length,this.memory=this.memory.slice(e.length)}this.memory=this.text.slice(this.text_index,this.text_index+this.memory.length+e)}Can_Use_Token(e,t,_){return _?Unicode.Expected_UTF_8_Unit_Count(e)<Unicode.Expected_UTF_8_Unit_Count(t):e.length<t.length}Create_Non_Token(e){return 0,e.codePointAt(0)>LZSS_ESCAPE_INDEX?e:LZSS_ESCAPE_STRING+e}Token_Or_Non_Token(e,t){0;const _=e.Point();if(this.Initial_Matches(this.matches_buffer_a,_),this.matches_buffer_a.length>0){const n=e.Points();let o=this.matches_buffer_b,s=this.matches_buffer_a,r=o;for(;s.length>0;)r=o,o=s,s=r,this.Matches(o,s,n);const S=o[o.length-1],i=this.memory.length-S[0],a=S[1]-S[0],l=LZSS_Create_Token(i,a);return this.Can_Use_Token(l,n.slice(0,a),t)?(this.Move_Memory(a),[l,new Unicode.Iterator({text:e.Text(),index:e.Index()+a})]):(this.Move_Memory(_.length),[this.Create_Non_Token(_),new Unicode.Iterator({text:e.Text(),index:e.Index()+_.length})])}return this.Move_Memory(_.length),[this.Create_Non_Token(_),new Unicode.Iterator({text:e.Text(),index:e.Index()+_.length})]}}export function LZSS_Compress(e,{max_memory_length:t,optimize_for_utf_8_encoding:_}={max_memory_length:1024,optimize_for_utf_8_encoding:!0}){0,0;const n=new LZSS_Window({text:e,max_memory_length:t});let o=LZSS_Create_Header(e.length),s=new Unicode.Iterator({text:e});for(;!s.Is_At_End();){const[e,t]=n.Token_Or_Non_Token(s,_);o+=e,s=t}return o}export function LZSS_Decompress(e){let t,_=new Unicode.Iterator({text:e});[_,t]=LZSS_Read_Header(_);const n=new Uint16Array(t);let o=0;for(;!_.Is_At_End();){const e=_.Point();if(e===LZSS_ESCAPE_STRING){_=_.Next();const e=_.Point();_=_.Next(),n[o]=e.charCodeAt(0),o+=1,2===e.length&&(n[o]=e.charCodeAt(1),o+=1)}else{if(e.codePointAt(0)<LZSS_ESCAPE_INDEX){let e,t;[_,e,t]=LZSS_Read_Token(_);const s=o-e,r=s+t;n.copyWithin(o,s,r),o+=t}else{const t=e;_=_.Next(),n[o]=t.charCodeAt(0),o+=1,2===t.length&&(n[o]=t.charCodeAt(1),o+=1)}}}return 0,Utils.Is_Big_Endian()?new TextDecoder("utf-16be").decode(n):new TextDecoder("utf-16le").decode(n)}