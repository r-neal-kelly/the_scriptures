var __awaiter=this&&this.__awaiter||function(t,e,o,n){return new(o||(o=Promise))((function(a,r){function i(t){try{_(n.next(t))}catch(t){r(t)}}function s(t){try{_(n.throw(t))}catch(t){r(t)}}function _(t){var e;t.done?a(t.value):(e=t.value,e instanceof o?e:new o((function(t){t(e)}))).then(i,s)}_((n=n.apply(t,e||[])).next())}))};import*as fs from"fs";import*as Utils from"../utils.js";import*as Unicode from"../unicode.js";import*as Language from"../model/language.js";import*as Data from"../model/data.js";import*as Text from"../model/text.js";const LINE_PATH_TYPE=Text.Line.Path_Type.DEFAULT;function Read_Directory(t){return __awaiter(this,void 0,void 0,(function*(){return new Promise((function(e,o){fs.readdir(t,{withFileTypes:!0},(function(t,n){null!=t?o(t):e(n)}))}))}))}function Has_File(t){return fs.existsSync(t)}function Read_File(t,e="utf8"){return __awaiter(this,void 0,void 0,(function*(){return new Promise((function(o,n){fs.readFile(t,e,(function(t,e){null!=t?n(t):o(e)}))}))}))}function Write_File(t,e,o="utf8"){return __awaiter(this,void 0,void 0,(function*(){return new Promise((function(n,a){fs.writeFile(t,e,o,(function(t){null!=t?a(t):n()}))}))}))}function Folder_Names(t){return __awaiter(this,void 0,void 0,(function*(){const e=[],o=yield Read_Directory(t);for(let t of o)t.isDirectory()&&e.push(t.name);return e}))}function File_Names(t){return __awaiter(this,void 0,void 0,(function*(){const e=[],o=yield Read_Directory(t);for(let t of o)t.isFile()&&e.push(t.name);return e}))}class Unique_Names{constructor(){this.name_sorter=new Data.Name_Sorter.Instance,this.books=new Set,this.languages=new Set,this.versions=new Set}Add_Book(t){this.books.add(t)}Add_Language(t){this.languages.add(t)}Add_Version(t){this.versions.add(t)}Books(){return this.name_sorter.With_Set(Data.Name_Sorter.Type.BOOKS,this.books)}Languages(){return this.name_sorter.With_Set(Data.Name_Sorter.Type.LANGUAGES,this.languages)}Versions(){return this.name_sorter.With_Set(Data.Name_Sorter.Type.VERSIONS,this.versions)}}class Unique_Parts{constructor(){this.parts={}}Add(t){this.parts.hasOwnProperty(t)?(Utils.Assert(this.parts[t]<Number.MAX_SAFE_INTEGER,"Cannot add more of this unique part!"),this.parts[t]+=1):this.parts[t]=1}Values(){return Object.keys(this.parts).sort(function(t,e){return this.parts[e]-this.parts[t]}.bind(this))}Count(t){return Utils.Assert(this.parts.hasOwnProperty(t),"Does not have part."),this.parts[t]}}function Filter_File_Names(t){return/\.txt$/.test(t)&&!/COPY\.txt$/.test(t)}function Sorted_File_Names(t){return __awaiter(this,void 0,void 0,(function*(){return Has_File(`${t}/Order.json`)?JSON.parse(yield Read_File(`${t}/Order.json`)):(yield File_Names(t)).filter(Filter_File_Names).sort()}))}function Assert_Greek_Normalization(t,e){Utils.Assert(Language.Greek.Normalize_With_Combined_Points(Language.Greek.Normalize_With_Baked_Points(e))===e,`\n            failed to reproduce original file_text after Greek normalization\n            ${t}\n        `)}function Read_And_Write_With_No_Carriage_Returns(t){return __awaiter(this,void 0,void 0,(function*(){let e=yield Read_File(t);return/\r/.test(e)&&(e=e.replace(/\r?\n/g,"\n"),yield Write_File(t,e)),e}))}function Decompression_Line_Mismatches(t,e){const o=t.split(/\r?\n/),n=e.split(/\r?\n/);let a="";for(let t=0,e=o.length;t<e;t+=1)t<n.length?o[t]!==n[t]&&(a+=`${t}: ${o[t]} !== ${n[t]}\n`):a+=`${t}: <missing line>\n`;return""===a?"<no mismatching lines>":a}function Generate(){return __awaiter(this,void 0,void 0,(function*(){const t={tree:{books:[]},unique_book_names:[],unique_language_names:[],unique_version_names:[],total_unit_count:0,total_point_count:0,total_letter_count:0,total_marker_count:0,total_meta_letter_count:0,total_word_count:0,total_break_count:0,total_meta_word_count:0,total_part_count:0,total_line_count:0,total_file_count:0,total_book_count:0},e=new Unique_Names;function o(t,e){const o=e.Part_Type(),n=e.Value(),a=n.length,r=Unicode.Point_Count(n);if(Utils.Assert(t.total_unit_count+a<=Number.MAX_SAFE_INTEGER),t.total_unit_count+=a,Utils.Assert(t.total_point_count+r<=Number.MAX_SAFE_INTEGER),t.total_point_count+=r,o===Text.Part.Type.LETTER)Utils.Assert(t.total_letter_count+1<=Number.MAX_SAFE_INTEGER),t.total_letter_count+=1,Utils.Assert(t.total_part_count+1<=Number.MAX_SAFE_INTEGER),t.total_part_count+=1;else if(o===Text.Part.Type.MARKER)Utils.Assert(t.total_marker_count+1<=Number.MAX_SAFE_INTEGER),t.total_marker_count+=1,Utils.Assert(t.total_part_count+1<=Number.MAX_SAFE_INTEGER),t.total_part_count+=1;else if(o===Text.Part.Type.WORD)Utils.Assert(t.total_letter_count+r<=Number.MAX_SAFE_INTEGER),t.total_letter_count+=r,Utils.Assert(t.total_word_count+1<=Number.MAX_SAFE_INTEGER),t.total_word_count+=1,Utils.Assert(t.total_part_count+1<=Number.MAX_SAFE_INTEGER),t.total_part_count+=1;else if(o===Text.Part.Type.BREAK)Utils.Assert(t.total_marker_count+r<=Number.MAX_SAFE_INTEGER),t.total_marker_count+=r,Utils.Assert(t.total_break_count+1<=Number.MAX_SAFE_INTEGER),t.total_break_count+=1,Utils.Assert(t.total_part_count+1<=Number.MAX_SAFE_INTEGER),t.total_part_count+=1;else if(o===Text.Part.Type.COMMAND){const o=e;Utils.Assert(t.total_meta_letter_count+r<=Number.MAX_SAFE_INTEGER),t.total_meta_letter_count+=r,o.Is_Last_Of_Split()||(Utils.Assert(t.total_meta_word_count+1<=Number.MAX_SAFE_INTEGER),t.total_meta_word_count+=1,Utils.Assert(t.total_part_count+1<=Number.MAX_SAFE_INTEGER),t.total_part_count+=1)}}yield function(){return __awaiter(this,void 0,void 0,(function*(){const n="./data",a=`${n}/Books`;for(const n of(yield Folder_Names(a)).sort()){const r=`${a}/${n}`,i={name:n,languages:[]};t.tree.books.push(i),e.Add_Book(n);for(const a of(yield Folder_Names(r)).sort()){const s=`${r}/${a}`,_={name:a,versions:[]};i.languages.push(_),e.Add_Language(a);for(const r of(yield Folder_Names(s)).sort()){const i=`${s}/${r}`,l=yield Sorted_File_Names(i),u={name:r,files:[]},c=new Text.Dictionary.Instance({json:yield Read_File(`${i}/Dictionary.json`)}),d=new Unique_Parts;_.versions.push(u),e.Add_Version(r),c.Validate(),t.total_book_count+=1,t.total_file_count+=l.length;for(const e of l){const s=`${i}/${e}`,_=Utils.Remove_File_Extension(e),l=yield Read_And_Write_With_No_Carriage_Returns(s),m=new Text.Instance({dictionary:c,value:l});u.files.push(_),t.total_line_count+=m.Line_Count();for(let i=0,s=m.Line_Count();i<s;i+=1){const s=m.Line(i);for(let _=0,l=s.Macro_Part_Count(LINE_PATH_TYPE);_<l;_+=1){const l=s.Macro_Part(_,LINE_PATH_TYPE);Utils.Assert(!l.Is_Unknown(),`Unknown part! Cannot generate:\n   Book Name:          ${n}\n   Language Name:      ${a}\n   Version Name:       ${r}\n   File Name:          ${e}\n   Line Index:         ${i}\n   Macro Part Index:   ${_}\n   Macro Part Value:   ${l.Value()}\n`),l.Is_Error()&&Utils.Assert(l.Has_Error_Style(),`Error not wrapped with error command! Should not generate:\n   Book Name:          ${n}\n   Language Name:      ${a}\n   Version Name:       ${r}\n   File Name:          ${e}\n   Line Index:         ${i}\n   Macro Part Index:   ${_}\n   Macro Part Value:   ${l.Value()}\n`),d.Add(l.Value()),o(t,l)}}}yield Write_File(`${i}/Unique_Parts.json`,JSON.stringify(d.Values()))}}}t.unique_book_names=e.Books(),t.unique_language_names=e.Languages(),t.unique_version_names=e.Versions(),Utils.Assert(t.total_word_count+t.total_meta_word_count+t.total_break_count===t.total_part_count,"Miscount of total_part_count"),Utils.Assert(t.total_letter_count+t.total_meta_letter_count+t.total_marker_count===t.total_point_count,"Miscount of total_point_count."),yield Write_File(`${n}/Info.json`,JSON.stringify(t))}))}(),yield function(){return __awaiter(this,void 0,void 0,(function*(){const t="./data/Books";for(const e of(yield Folder_Names(t)).sort()){const o=`${t}/${e}`;for(const t of(yield Folder_Names(o)).sort()){const n=`${o}/${t}`;for(const o of(yield Folder_Names(n)).sort()){const a=`${n}/${o}`,r=yield Sorted_File_Names(a),i=[],s=yield Read_File(`${a}/Dictionary.json`),_=yield Read_File(`${a}/Unique_Parts.json`),l=new Text.Dictionary.Instance({json:s}),u=new Data.Compressor.Instance({unique_parts:JSON.parse(_)}),c=u.Compress_Dictionary({dictionary_value:s}),d=u.Decompress_Dictionary({dictionary_value:c});Utils.Assert(d===s,"Invalid dictionary decompression!"),yield Write_File(`${a}/${Data.Version.Dictionary.Symbol.NAME}.${Data.Version.Dictionary.Symbol.EXTENSION}`,c);for(const n of r){const r=`${a}/${n}`,s=yield Read_File(r);i.push(s),Assert_Greek_Normalization(r,s);const _=u.Compress_File({dictionary:l,file_value:s}),c=u.Decompress_File({dictionary:l,file_value:_});Utils.Assert(c===s,`Invalid decompression!\n   Book Name: ${e}\n   Language Name: ${t}\n   Version Name: ${o}\n   File Name: ${n}\n${Decompression_Line_Mismatches(s,c)}`),yield Write_File(`${a}/${n.replace(/\.[^.]*$/,`.${Data.Version.Dictionary.Symbol.EXTENSION}`)}`,_)}const m=i.join(Data.Version.Symbol.FILE_BREAK),f=u.Compress_File({dictionary:l,file_value:m}),N=u.Decompress_File({dictionary:l,file_value:f});Utils.Assert(N===m,`Invalid decompression!\n   Book Name: ${e}\n   Language Name: ${t}\n   Version Name: ${o}\n${Decompression_Line_Mismatches(m,N)}`),yield Write_File(`${a}/${Data.Version.Text.Symbol.NAME}.${Data.Version.Text.Symbol.EXTENSION}`,f)}}}}))}(),yield function(){return __awaiter(this,void 0,void 0,(function*(){let e=yield Read_File("./README.md");const o="## Stats";let n=null,a=null;for(let t=0,r=e.length;t<r;t+=1){const r=e.slice(t);null===n?r.slice(0,o.length)===o&&(n=t):null===a&&"##"===r.slice(0,"##".length)&&(a=t)}if(null!==n){null===a&&(a=e.length);const o=Math.round(100*t.total_word_count/t.total_part_count),r=Math.round(100*t.total_meta_word_count/t.total_part_count),i=Math.round(100*t.total_break_count/t.total_part_count),s=Math.round(100*t.total_letter_count/t.total_point_count),_=Math.round(100*t.total_meta_letter_count/t.total_point_count),l=Math.round(100*t.total_marker_count/t.total_point_count);e=e.slice(0,n)+"## Stats\n\n"+`- Unique Languages: ${Utils.Add_Commas_To_Number(t.unique_language_names.length)}\n`+`- Unique Versions: ${Utils.Add_Commas_To_Number(t.unique_version_names.length)}\n`+`- Unique Books: ${Utils.Add_Commas_To_Number(t.unique_book_names.length)}\n\n<br>\n\n`+`- Total Books: ${Utils.Add_Commas_To_Number(t.total_book_count)}\n`+`- Total Files: ${Utils.Add_Commas_To_Number(t.total_file_count)}\n`+`- Total Lines: ${Utils.Add_Commas_To_Number(t.total_line_count)}\n`+`- Total Parts: ${Utils.Add_Commas_To_Number(t.total_part_count)}\n`+`    - Words: ${Utils.Add_Commas_To_Number(t.total_word_count)} (~${o}%)\n`+`    - Meta-Words: ${Utils.Add_Commas_To_Number(t.total_meta_word_count)} (~${r}%)\n`+`    - Non-Words: ${Utils.Add_Commas_To_Number(t.total_break_count)} (~${i}%)\n`+`- Total Unicode Points: ${Utils.Add_Commas_To_Number(t.total_point_count)}\n`+`    - Letters: ${Utils.Add_Commas_To_Number(t.total_letter_count)} (~${s}%)\n`+`    - Meta-Letters: ${Utils.Add_Commas_To_Number(t.total_meta_letter_count)} (~${_}%)\n`+`    - Non-Letters: ${Utils.Add_Commas_To_Number(t.total_marker_count)} (~${l}%)\n`+e.slice(a,e.length)}yield Write_File("./README.md",e)}))}()}))}!function(){__awaiter(this,void 0,void 0,(function*(){yield Generate()}))}();