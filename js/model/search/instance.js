var Node_Type,__awaiter=this&&this.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(o,n){function p(e){try{i(s.next(e))}catch(e){n(e)}}function a(e){try{i(s.throw(e))}catch(e){n(e)}}function i(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(p,a)}i((s=s.apply(e,t||[])).next())}))};import*as Utils from"../../utils.js";import*as Unicode from"../../unicode.js";import*as Entity from"../entity.js";import*as Data from"../data.js";export var Operator;!function(e){e.OPEN_VERBATIM='"',e.CLOSE_VERBATIM='"',e.OPEN_GROUP="(",e.CLOSE_GROUP=")",e.OPEN_SEQUENCE="<",e.CLOSE_SEQUENCE=">",e.NOT="!",e.FUZZY="*",e.AND="&",e.XOR="^",e.OR="|"}(Operator||(Operator={}));class Fragment{constructor(e,t){this.in_node=e,this.out_nodes=t,Object.freeze(this.out_nodes),Object.freeze(this)}In_Node(){return this.in_node}Out_Nodes(){return this.out_nodes}}!function(e){e[e.TEXT=0]="TEXT",e[e.OR=1]="OR",e[e.XOR=2]="XOR",e[e.AND=3]="AND",e[e.NOT=4]="NOT",e[e.FUZZY=5]="FUZZY",e[e.SEQUENCE=6]="SEQUENCE",e[e.END=7]="END"}(Node_Type||(Node_Type={}));class Node{constructor({type:e}){this.type=e,this.next=null}Type(){return this.type}Next(){return this.next}Set_Next(e){this.next=e,Object.freeze(this)}}class Text extends Node{constructor({value:e}){super({type:Node_Type.TEXT}),this.value=e}Value(){return this.value}}class Binary extends Node{constructor({type:e,left:t,right:r}){super({type:e}),super.Set_Next(t),this.alternate_next=r,Object.freeze(this)}Next(){return Utils.Assert(!1,"Unused method."),null}Set_Next(e){Utils.Assert(!1,"Unused method.")}Left(){return this.Next()}Right(){return this.alternate_next}}class Or extends Binary{constructor({left:e,right:t}){super({type:Node_Type.OR,left:e,right:t})}}class Xor extends Binary{constructor({left:e,right:t}){super({type:Node_Type.XOR,left:e,right:t})}}class Unary extends Node{constructor({type:e,expression:t}){super({type:e}),this.expression=t}Expression(){return this.expression}}class Not extends Unary{constructor({expression:e}){super({type:Node_Type.NOT,expression:e})}}class Fuzzy extends Unary{constructor({expression:e}){super({type:Node_Type.FUZZY,expression:e})}}class Sequence extends Unary{constructor({expression:e}){super({type:Node_Type.SEQUENCE,expression:e})}}class End extends Node{constructor(){super({type:Node_Type.END})}Next(){return Utils.Assert(!1,"Unused method."),null}Set_Next(e){Utils.Assert(!1,"Unused method.")}}const END=new End;export class Instance extends Entity.Instance{constructor({book_names:e=null,language_names:t=null,version_names:r=null}){super(),this.book_names=null!=e?Array.from(e):null,this.language_names=null!=t?Array.from(t):null,this.version_names=null!=r?Array.from(r):null,this.Add_Dependencies([Data.Singleton()])}Compile(e){function t(e,t){if(e===Operator.CLOSE_SEQUENCE||e===Operator.NOT||e===Operator.FUZZY){Utils.Assert(t.length>0,"Corrupt fragments.");const r=t.pop();for(const e of r.Out_Nodes())e.Set_Next(END);const s=e===Operator.CLOSE_SEQUENCE?new Sequence({expression:r.In_Node()}):e===Operator.NOT?new Not({expression:r.In_Node()}):new Fuzzy({expression:r.In_Node()});t.push(new Fragment(s,[s]))}else if(e===Operator.AND){Utils.Assert(t.length>1,"Corrupt fragments.");const e=t.pop(),r=t.pop();for(const t of r.Out_Nodes())t.Set_Next(e.In_Node());t.push(new Fragment(r.In_Node(),e.Out_Nodes()))}else if(e===Operator.OR||e===Operator.XOR){const r=t.pop(),s=t.pop(),o=e===Operator.OR?new Or({left:s.In_Node(),right:r.In_Node()}):new Xor({left:s.In_Node(),right:r.In_Node()});t.push(new Fragment(o,s.Out_Nodes().concat(r.Out_Nodes())))}else Utils.Assert(!1,`Unworkable operator: ${e}.`)}const r=[],s=[];let o=new Unicode.Iterator({text:e}),n=0,p=!1,a=0;for(;!o.Is_At_End();o=o.Next()){const e=o.Point();if(e===Operator.OPEN_VERBATIM)n>0&&(p=!0);else if(e===Operator.OPEN_SEQUENCE)Utils.Assert(0===n,"Cannot have sequences within sequences."),r.push(Operator.OPEN_SEQUENCE),n+=1,p=!1;else if(e===Operator.CLOSE_SEQUENCE){Utils.Assert(n>0,"Missing open_sequence operator.");for(let e=r.pop();e!=Operator.OPEN_SEQUENCE;e=r.pop())t(e,s);p&&(t(Operator.CLOSE_SEQUENCE,s),p=!1),n-=1}else if(e===Operator.OPEN_GROUP)r.push(Operator.OPEN_GROUP),a+=1;else if(e===Operator.CLOSE_GROUP){Utils.Assert(a>0,"Missing open_group operator.");for(let e=r.pop();e!=Operator.OPEN_GROUP;e=r.pop())t(e,s);a-=1}else if(e===Operator.NOT||e===Operator.FUZZY)r.push(e);else if(e===Operator.AND){for(Utils.Assert(s.length>0,"Dangling operator.");r.length>0&&r[r.length-1]===Operator.NOT||r[r.length-1]===Operator.FUZZY||r[r.length-1]===Operator.AND;)t(r.pop(),s);r.push(Operator.AND)}else if(e===Operator.XOR){for(Utils.Assert(s.length>0,"Dangling operator.");r.length>0&&r[r.length-1]===Operator.NOT||r[r.length-1]===Operator.FUZZY||r[r.length-1]===Operator.AND||r[r.length-1]===Operator.XOR;)t(r.pop(),s);r.push(Operator.XOR)}else if(e===Operator.OR){for(Utils.Assert(s.length>0,"Dangling operator.");r.length>0&&r[r.length-1]===Operator.NOT||r[r.length-1]===Operator.FUZZY||r[r.length-1]===Operator.AND||r[r.length-1]===Operator.XOR||r[r.length-1]===Operator.OR;)t(r.pop(),s);r.push(Operator.OR)}else n>0&&(p=!0)}for(Utils.Assert(0===n,"Missing close_sequence operator."),Utils.Assert(0===a,"Missing close_group operator.");r.length>0;)t(r.pop(),s);Utils.Assert(1===s.length,"Corrupt fragments.");const i=s.pop();for(const e of i.Out_Nodes())e.Set_Next(END);return i.In_Node()}After_Dependencies_Are_Ready(){return __awaiter(this,void 0,void 0,(function*(){}))}}