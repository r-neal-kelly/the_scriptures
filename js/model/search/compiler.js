import*as Utils from"../../utils.js";import*as Token from"./token.js";import*as Node from"./node.js";class Fragment{constructor(e,o){this.in_node=e,this.out_nodes=o,Object.freeze(this.out_nodes),Object.freeze(this)}In_Node(){return this.in_node}Out_Nodes(){return this.out_nodes}}export class Instance{constructor(){}Compile(e){const o=[],n=[];function T(e){for(;o.length>0&&e.includes(o[o.length-1].Type());)p(o.pop())}function p(e){const o=e.Type();if(o===Token.Type.MAYBE_ONE){Utils.Assert(n.length>=1,"Corrupt fragments.");const e=n.pop(),o=new Node.Maybe_One({operand:e.In_Node()});n.push(new Fragment(o,[o].concat(e.Out_Nodes())))}else if(o===Token.Type.MAYBE_MANY){Utils.Assert(n.length>=1,"Corrupt fragments.");const e=n.pop(),o=new Node.Maybe_Many({operand:e.In_Node()});for(const n of e.Out_Nodes())n.Set_Next(o);n.push(new Fragment(o,[o]))}else if(o===Token.Type.ONE_OR_MANY){Utils.Assert(n.length>=1,"Corrupt fragments.");const e=n.pop(),o=new Node.One_Or_Many({operand:e.In_Node()});for(const n of e.Out_Nodes())n.Set_Next(o);n.push(new Fragment(e.In_Node(),[o]))}else if(o===Token.Type.NOT||o===Token.Type.CASE||o===Token.Type.ALIGN||o===Token.Type.META){Utils.Assert(n.length>=1,"Corrupt fragments.");const e=n.pop();for(const o of e.Out_Nodes())o.Set_Next(Node.END);const T=o===Token.Type.NOT?new Node.Not({operand:e.In_Node()}):o===Token.Type.CASE?new Node.Case({operand:e.In_Node()}):o===Token.Type.ALIGN?new Node.Align({operand:e.In_Node()}):new Node.Meta({operand:e.In_Node()});n.push(new Fragment(T,[T]))}else if(o===Token.Type.AND){Utils.Assert(n.length>=2,"Corrupt fragments.");const e=n.pop(),o=n.pop();for(const n of o.Out_Nodes())n.Set_Next(e.In_Node());n.push(new Fragment(o.In_Node(),e.Out_Nodes()))}else if(o===Token.Type.OR||o===Token.Type.XOR){Utils.Assert(n.length>=2,"Corrupt fragments.");const e=n.pop(),T=n.pop(),p=o===Token.Type.OR?new Node.Or({left_operand:T.In_Node(),right_operand:e.In_Node()}):new Node.Xor({left_operand:T.In_Node(),right_operand:e.In_Node()});n.push(new Fragment(p,T.Out_Nodes().concat(e.Out_Nodes())))}else Utils.Assert(!1,`Unworkable operator_type: ${o}.`)}for(const t of e){const e=t.Type();if(e===Token.Type.MAYBE_ONE||e===Token.Type.MAYBE_MANY||e===Token.Type.ONE_OR_MANY)T([Token.Type.MAYBE_ONE,Token.Type.MAYBE_MANY,Token.Type.ONE_OR_MANY]),o.push(t);else if(e===Token.Type.OPEN_GROUP)T([Token.Type.MAYBE_ONE,Token.Type.MAYBE_MANY,Token.Type.ONE_OR_MANY]),o.push(t);else if(e===Token.Type.CLOSE_GROUP)for(let e=o.pop();null!=e&&e.Type()!=Token.Type.OPEN_GROUP;e=o.pop())p(e);else if(e===Token.Type.OPEN_SEQUENCE)T([Token.Type.MAYBE_ONE,Token.Type.MAYBE_MANY,Token.Type.ONE_OR_MANY]),o.push(t);else if(e===Token.Type.CLOSE_SEQUENCE){for(let e=o.pop();null!=e&&e.Type()!=Token.Type.OPEN_SEQUENCE;e=o.pop())p(e);Utils.Assert(n.length>=1,"Corrupt fragments.");const e=n.pop();for(const o of e.Out_Nodes())o.Set_Next(Node.END);const T=new Node.Sequence({operand:e.In_Node(),token:t});n.push(new Fragment(T,[T]))}else if(e===Token.Type.NOT||e===Token.Type.CASE||e===Token.Type.ALIGN||e===Token.Type.META)o.push(t);else if(e===Token.Type.AND)T([Token.Type.MAYBE_ONE,Token.Type.MAYBE_MANY,Token.Type.ONE_OR_MANY,Token.Type.NOT,Token.Type.CASE,Token.Type.ALIGN,Token.Type.META,Token.Type.AND]),o.push(t);else if(e===Token.Type.XOR)T([Token.Type.MAYBE_ONE,Token.Type.MAYBE_MANY,Token.Type.ONE_OR_MANY,Token.Type.NOT,Token.Type.CASE,Token.Type.ALIGN,Token.Type.META,Token.Type.AND,Token.Type.XOR]),o.push(t);else if(e===Token.Type.OR)T([Token.Type.MAYBE_ONE,Token.Type.MAYBE_MANY,Token.Type.ONE_OR_MANY,Token.Type.NOT,Token.Type.CASE,Token.Type.ALIGN,Token.Type.META,Token.Type.AND,Token.Type.XOR,Token.Type.OR]),o.push(t);else if(e===Token.Type.TEXT){const e=new Node.Text({token:t});n.push(new Fragment(e,[e]))}else if(e===Token.Type.CLASS){const e=new Node.Class({token:t});n.push(new Fragment(e,[e]))}else Utils.Assert(1===n.length,`Unknown token type: ${t.Type()}.`)}for(;o.length>0;)p(o.pop());Utils.Assert(1===n.length,"Corrupt fragments.");const t=n.pop();for(const e of t.Out_Nodes())e.Set_Next(Node.END);return t.In_Node()}}