import*as Utils from"../../utils.js";import*as Token from"./token.js";import*as Node from"./node.js";class Fragment{constructor(e,o){this.in_node=e,this.out_nodes=o,Object.freeze(this.out_nodes),Object.freeze(this)}In_Node(){return this.in_node}Out_Nodes(){return this.out_nodes}}export class Instance{constructor(){}Compile(e){function o(e,o){const n=e.Type();if(n===Token.Type.OPEN_SEQUENCE||n===Token.Type.NOT||n===Token.Type.CASE||n===Token.Type.ALIGN){Utils.Assert(o.length>=1,"Corrupt fragments.");const e=o.pop();for(const o of e.Out_Nodes())o.Set_Next(Node.END);const p=n===Token.Type.OPEN_SEQUENCE?new Node.Sequence({operand:e.In_Node()}):n===Token.Type.NOT?new Node.Not({operand:e.In_Node()}):n===Token.Type.CASE?new Node.Case({operand:e.In_Node()}):new Node.Align({operand:e.In_Node()});o.push(new Fragment(p,[p]))}else if(n===Token.Type.AND){Utils.Assert(o.length>=2,"Corrupt fragments.");const e=o.pop(),n=o.pop();for(const o of n.Out_Nodes())o.Set_Next(e.In_Node());o.push(new Fragment(n.In_Node(),e.Out_Nodes()))}else if(n===Token.Type.OR||n===Token.Type.XOR){Utils.Assert(o.length>=2,"Corrupt fragments.");const e=o.pop(),p=o.pop(),t=n===Token.Type.OR?new Node.Or({left_operand:p.In_Node(),right_operand:e.In_Node()}):new Node.Xor({left_operand:p.In_Node(),right_operand:e.In_Node()});o.push(new Fragment(t,p.Out_Nodes().concat(e.Out_Nodes())))}else Utils.Assert(!1,`Unworkable operator_type: ${n}.`)}const n=[],p=[];for(const t of e){const e=t.Type();if(e===Token.Type.OPEN_GROUP)n.push(t);else if(e===Token.Type.CLOSE_GROUP)for(let e=n.pop();null!=e&&e.Type()!=Token.Type.OPEN_GROUP;e=n.pop())o(e,p);else if(e===Token.Type.OPEN_SEQUENCE)n.push(t);else if(e===Token.Type.CLOSE_SEQUENCE){let e=n.pop();for(;null!=e&&e.Type()!=Token.Type.OPEN_SEQUENCE;e=n.pop())o(e,p);o(e,p)}else if(e===Token.Type.NOT)n.push(t);else if(e===Token.Type.CASE)n.push(t);else if(e===Token.Type.ALIGN)n.push(t);else if(e===Token.Type.AND){for(;n.length>0&&n[n.length-1].Type()===Token.Type.NOT||n[n.length-1].Type()===Token.Type.CASE||n[n.length-1].Type()===Token.Type.ALIGN||n[n.length-1].Type()===Token.Type.AND;)o(n.pop(),p);n.push(t)}else if(e===Token.Type.XOR){for(;n.length>0&&n[n.length-1].Type()===Token.Type.NOT||n[n.length-1].Type()===Token.Type.CASE||n[n.length-1].Type()===Token.Type.ALIGN||n[n.length-1].Type()===Token.Type.AND||n[n.length-1].Type()===Token.Type.XOR;)o(n.pop(),p);n.push(t)}else if(e===Token.Type.OR){for(;n.length>0&&n[n.length-1].Type()===Token.Type.NOT||n[n.length-1].Type()===Token.Type.CASE||n[n.length-1].Type()===Token.Type.ALIGN||n[n.length-1].Type()===Token.Type.AND||n[n.length-1].Type()===Token.Type.XOR||n[n.length-1].Type()===Token.Type.OR;)o(n.pop(),p);n.push(t)}else if(e===Token.Type.TEXT){const e=new Node.Text({token:t});p.push(new Fragment(e,[e]))}else Utils.Assert(1===p.length,`Unknown token type: ${t.Type()}.`)}for(;n.length>0;)o(n.pop(),p);Utils.Assert(1===p.length,"Corrupt fragments.");const t=p.pop();for(const e of t.Out_Nodes())e.Set_Next(Node.END);return t.In_Node()}}