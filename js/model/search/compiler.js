import*as Utils from"../../utils.js";import*as Token from"./token.js";import*as Node from"./node.js";class Fragment{constructor(e,o){this.in_node=e,this.out_nodes=o,Object.freeze(this.out_nodes),Object.freeze(this)}In_Node(){return this.in_node}Out_Nodes(){return this.out_nodes}}export class Instance{constructor(){}Compile(e){function o(e,o){const n=e.Type();if(n===Token.Type.NOT||n===Token.Type.CASE||n===Token.Type.ALIGN||n===Token.Type.META){Utils.Assert(o.length>=1,"Corrupt fragments.");const e=o.pop();for(const o of e.Out_Nodes())o.Set_Next(Node.END);const t=n===Token.Type.NOT?new Node.Not({operand:e.In_Node()}):n===Token.Type.CASE?new Node.Case({operand:e.In_Node()}):n===Token.Type.ALIGN?new Node.Align({operand:e.In_Node()}):new Node.Meta({operand:e.In_Node()});o.push(new Fragment(t,[t]))}else if(n===Token.Type.AND){Utils.Assert(o.length>=2,"Corrupt fragments.");const e=o.pop(),n=o.pop();for(const o of n.Out_Nodes())o.Set_Next(e.In_Node());o.push(new Fragment(n.In_Node(),e.Out_Nodes()))}else if(n===Token.Type.OR||n===Token.Type.XOR){Utils.Assert(o.length>=2,"Corrupt fragments.");const e=o.pop(),t=o.pop(),p=n===Token.Type.OR?new Node.Or({left_operand:t.In_Node(),right_operand:e.In_Node()}):new Node.Xor({left_operand:t.In_Node(),right_operand:e.In_Node()});o.push(new Fragment(p,t.Out_Nodes().concat(e.Out_Nodes())))}else Utils.Assert(!1,`Unworkable operator_type: ${n}.`)}const n=[],t=[];for(const p of e){const e=p.Type();if(e===Token.Type.OPEN_GROUP)n.push(p);else if(e===Token.Type.CLOSE_GROUP)for(let e=n.pop();null!=e&&e.Type()!=Token.Type.OPEN_GROUP;e=n.pop())o(e,t);else if(e===Token.Type.OPEN_SEQUENCE)n.push(p);else if(e===Token.Type.CLOSE_SEQUENCE){for(let e=n.pop();null!=e&&e.Type()!=Token.Type.OPEN_SEQUENCE;e=n.pop())o(e,t);Utils.Assert(t.length>=1,"Corrupt fragments.");const e=t.pop();for(const o of e.Out_Nodes())o.Set_Next(Node.END);const T=new Node.Sequence({operand:e.In_Node(),token:p});t.push(new Fragment(T,[T]))}else if(e===Token.Type.NOT)n.push(p);else if(e===Token.Type.CASE)n.push(p);else if(e===Token.Type.ALIGN)n.push(p);else if(e===Token.Type.META)n.push(p);else if(e===Token.Type.AND){for(;n.length>0&&(n[n.length-1].Type()===Token.Type.NOT||n[n.length-1].Type()===Token.Type.CASE||n[n.length-1].Type()===Token.Type.ALIGN||n[n.length-1].Type()===Token.Type.META||n[n.length-1].Type()===Token.Type.AND);)o(n.pop(),t);n.push(p)}else if(e===Token.Type.XOR){for(;n.length>0&&(n[n.length-1].Type()===Token.Type.NOT||n[n.length-1].Type()===Token.Type.CASE||n[n.length-1].Type()===Token.Type.ALIGN||n[n.length-1].Type()===Token.Type.META||n[n.length-1].Type()===Token.Type.AND||n[n.length-1].Type()===Token.Type.XOR);)o(n.pop(),t);n.push(p)}else if(e===Token.Type.OR){for(;n.length>0&&(n[n.length-1].Type()===Token.Type.NOT||n[n.length-1].Type()===Token.Type.CASE||n[n.length-1].Type()===Token.Type.ALIGN||n[n.length-1].Type()===Token.Type.META||n[n.length-1].Type()===Token.Type.AND||n[n.length-1].Type()===Token.Type.XOR||n[n.length-1].Type()===Token.Type.OR);)o(n.pop(),t);n.push(p)}else if(e===Token.Type.TEXT){const e=new Node.Text({token:p});t.push(new Fragment(e,[e]))}else Utils.Assert(1===t.length,`Unknown token type: ${p.Type()}.`)}for(;n.length>0;)o(n.pop(),t);Utils.Assert(1===t.length,"Corrupt fragments.");const p=t.pop();for(const e of p.Out_Nodes())e.Set_Next(Node.END);return p.In_Node()}}