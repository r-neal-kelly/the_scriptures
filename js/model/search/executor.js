import*as Utils from"../../utils.js";import*as Parser from"./parser.js";import*as Compiler from"./compiler.js";import*as Node from"./node.js";import*as Result from"./result.js";export var Mode;!function(e){e[e.INITIAL=0]="INITIAL",e[e.SEQUENCED=1]="SEQUENCED",e[e.NEGATED=2]="NEGATED",e[e.CASED=4]="CASED",e[e.ALIGNED=8]="ALIGNED"}(Mode||(Mode={}));export class Instance{constructor(){this.parser=new Parser.Instance,this.compiler=new Compiler.Instance}Execute(e,t){const n=this.parser.Parse(e,t.Dictionary());if(n instanceof Parser.Help)return n;{const e=this.compiler.Compile(n),s=[];for(let n=0,l=t.Line_Count();n<l;n+=1){const l=t.Line(n),r=this.Step(e,Mode.INITIAL,new Result.Instance(l));null!=r&&s.push(r)}return s}}Step(e,t,n){const s=e.Type();if(s===Node.Type.SEQUENCE){const s=e,l=this.Step(s.Operand(),t|Mode.SEQUENCED,new Result.Instance(n.Line()));return null!=l?this.Step(s.Next(),t,n.Combine(l)):null}if(s===Node.Type.NOT){const s=e,l=this.Step(s.Operand(),t^Mode.NEGATED,n);return null!=l?this.Step(s.Next(),t,l):null}if(s===Node.Type.CASE){const s=e,l=this.Step(s.Operand(),t^Mode.CASED,n);return null!=l?this.Step(s.Next(),t,l):null}if(s===Node.Type.ALIGN){const s=e,l=this.Step(s.Operand(),t^Mode.ALIGNED,n);return null!=l?this.Step(s.Next(),t,l):null}if(s===Node.Type.XOR){const s=e,l=this.Step(s.Left_Operand(),t,n.Copy()),r=this.Step(s.Right_Operand(),t,n.Copy());return null!=l?null!=r?null:l:null!=r?r:null}if(s===Node.Type.OR){const s=e,l=this.Step(s.Left_Operand(),t,n.Copy()),r=this.Step(s.Right_Operand(),t,n.Copy());return null!=l?null!=r?l.Combine(r):l:null!=r?r:null}if(s===Node.Type.TEXT){const s=e;let l;return l=t&Mode.SEQUENCED?t&Mode.NEGATED?t&Mode.CASED?t&Mode.ALIGNED?this.Sequenced_Negated_Cased_Aligned_Text(s,n):this.Sequenced_Negated_Cased_Text(s,n):t&Mode.ALIGNED?this.Sequenced_Negated_Aligned_Text(s,n):this.Sequenced_Negated_Text(s,n):t&Mode.CASED?t&Mode.ALIGNED?this.Sequenced_Cased_Aligned_Text(s,n):this.Sequenced_Cased_Text(s,n):t&Mode.ALIGNED?this.Sequenced_Aligned_Text(s,n):this.Sequenced_Text(s,n):t&Mode.NEGATED?t&Mode.CASED?t&Mode.ALIGNED?this.Negated_Cased_Aligned_Text(s,n):this.Negated_Cased_Text(s,n):t&Mode.ALIGNED?this.Negated_Aligned_Text(s,n):this.Negated_Text(s,n):t&Mode.CASED?t&Mode.ALIGNED?this.Cased_Aligned_Text(s,n):this.Cased_Text(s,n):t&Mode.ALIGNED?this.Aligned_Text(s,n):this.Text(s,n),null!=l?this.Step(s.Next(),t,l):null}return s===Node.Type.END?n:(Utils.Assert(!1,`Unknown node_type: ${s}`),null)}Sequenced_Negated_Cased_Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Negated_Cased_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Negated_Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Negated_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Cased_Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Cased_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Sequenced_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Negated_Cased_Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Negated_Cased_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Negated_Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Negated_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Cased_Aligned_Text(e,t){const n=t.Line(),s=e.Line();let l=!1;for(let e=0,r=n.Macro_Part_Count();e<r;e+=1)for(let d=0,i=s.Macro_Part_Count();d<i;d+=1)if(e+d<r){const r=n.Macro_Part(e+d).Value();if(r!==s.Macro_Part(d).Value())break;d===i-1&&(l=!0,t.Try_Add_Match(new Result.Match({first_part_index:e,end_part_index:e+i,first_part_first_unit_index:0,last_part_end_unit_index:r.length})))}return l?t:null}Cased_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Aligned_Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}Text(e,t){return Utils.Assert(!1,"Not implemented yet."),null}}