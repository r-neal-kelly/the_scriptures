import*as Utils from"../../utils.js";import*as Parser from"./parser.js";import*as Compiler from"./compiler.js";import*as Node from"./node.js";import*as Result from"./result.js";export var Mode;!function(e){e[e.INITIAL=0]="INITIAL",e[e.SEQUENCE=1]="SEQUENCE",e[e.NOT=2]="NOT",e[e.CASE=4]="CASE",e[e.ALIGN=8]="ALIGN",e[e.META=16]="META"}(Mode||(Mode={}));export class Instance{constructor(){this.parser=new Parser.Instance,this.compiler=new Compiler.Instance}Execute(e,t){const n=this.parser.Parse(e,t.Dictionary());if(n instanceof Parser.Help)return n;{const e=this.compiler.Compile(n),r=[];for(let n=0,o=t.Line_Count();n<o;n+=1){const o=t.Line(n),s=this.Step(e,Mode.INITIAL,new Result.Instance(o));null!=s&&r.push(s)}return r}}Step(e,t,n){const r=e.Type();if(r===Node.Type.SEQUENCE){const r=e,o=this.Step(r.Operand(),t|Mode.SEQUENCE,new Result.Instance(n.Line()));return null!=o?this.Step(r.Next(),t,n.Combine(o)):null}if(r===Node.Type.NOT){const r=e,o=this.Step(r.Operand(),t^Mode.NOT,n);return null!=o?this.Step(r.Next(),t,o):null}if(r===Node.Type.CASE){const r=e,o=this.Step(r.Operand(),t^Mode.CASE,n);return null!=o?this.Step(r.Next(),t,o):null}if(r===Node.Type.ALIGN){const r=e,o=this.Step(r.Operand(),t^Mode.ALIGN,n);return null!=o?this.Step(r.Next(),t,o):null}if(r===Node.Type.META){const r=e,o=this.Step(r.Operand(),t^Mode.META,n);return null!=o?this.Step(r.Next(),t,o):null}if(r===Node.Type.XOR){const r=e,o=this.Step(r.Left_Operand(),t,n.Copy()),s=this.Step(r.Right_Operand(),t,n.Copy());return null!=o?null!=s?null:o:null!=s?s:null}if(r===Node.Type.OR){const r=e,o=this.Step(r.Left_Operand(),t,n.Copy()),s=this.Step(r.Right_Operand(),t,n.Copy());return null!=o?null!=s?o.Combine(s):o:null!=s?s:null}if(r===Node.Type.TEXT){const r=e;let o;return o=t&Mode.SEQUENCE?t&Mode.NOT?this.Not_Sequence(r,t,n):this.Sequence(r,t,n):t&Mode.NOT?this.Not_Text(r,t,n):this.Text(r,t,n),null!=o?this.Step(r.Next(),t,o):null}return r===Node.Type.END?n:(Utils.Assert(!1,`Unknown node_type: ${r}`),null)}Text(e,t,n){const r=n.Line(),o=e.Line();let s=!1;for(let e=0,l=r.Macro_Part_Count();e<l;e+=1){let i=0;for(let p=0,u=o.Macro_Part_Count();p<u;p+=1){if(!(t&Mode.META))for(;e+i+p<l&&r.Macro_Part(e+i+p).Is_Command();)i+=1;if(!(e+i+p<l))break;{const t=r.Macro_Part(e+i+p),l=o.Macro_Part(p),a=t.Value();if(a!==l.Value())break;p===u-1&&(s=!0,n.Try_Add_Match(new Result.Match({first_part_index:e,end_part_index:e+i+u,first_part_first_unit_index:0,last_part_end_unit_index:a.length})))}}}return s?n:null}Not_Text(e,t,n){return null==this.Text(e,t,n)?n:null}Sequence(e,t,n){return Utils.Assert(!1,"Not implemented yet."),null}Not_Sequence(e,t,n){return Utils.Assert(!1,"Not implemented yet."),null}}