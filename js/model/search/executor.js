import*as Utils from"../../utils.js";import*as Parser from"./parser.js";import*as Compiler from"./compiler.js";import*as Node from"./node.js";import*as Result from"./result.js";export var Mode;!function(e){e[e.INITIAL=0]="INITIAL",e[e.SEQUENCE=1]="SEQUENCE",e[e.NOT=2]="NOT",e[e.CASE=4]="CASE",e[e.ALIGN=8]="ALIGN",e[e.META=16]="META"}(Mode||(Mode={}));export class Instance{constructor(){this.parser=new Parser.Instance,this.compiler=new Compiler.Instance}Execute(e,t){const n=this.parser.Parse(e,t.Dictionary());if(n instanceof Parser.Help)return n;{const e=this.compiler.Compile(n),l=[];for(let n=0,r=t.Line_Count();n<r;n+=1){const r=t.Line(n),s=this.Step(e,Mode.INITIAL,new Result.Instance(r));null!=s&&l.push(s)}return l}}Step(e,t,n){const l=e.Type();if(l===Node.Type.SEQUENCE){const l=e,r=this.Step(l.Operand(),t|Mode.SEQUENCE,new Result.Instance(n.Line()));return null!=r?this.Step(l.Next(),t,n.Combine(r)):null}if(l===Node.Type.NOT){const l=e,r=this.Step(l.Operand(),t^Mode.NOT,n);return null!=r?this.Step(l.Next(),t,r):null}if(l===Node.Type.CASE){const l=e,r=this.Step(l.Operand(),t^Mode.CASE,n);return null!=r?this.Step(l.Next(),t,r):null}if(l===Node.Type.ALIGN){const l=e,r=this.Step(l.Operand(),t^Mode.ALIGN,n);return null!=r?this.Step(l.Next(),t,r):null}if(l===Node.Type.META){const l=e,r=this.Step(l.Operand(),t^Mode.META,n);return null!=r?this.Step(l.Next(),t,r):null}if(l===Node.Type.XOR){const l=e,r=this.Step(l.Left_Operand(),t,n.Copy()),s=this.Step(l.Right_Operand(),t,n.Copy());return null!=r?null!=s?null:r:null!=s?s:null}if(l===Node.Type.OR){const l=e,r=this.Step(l.Left_Operand(),t,n.Copy()),s=this.Step(l.Right_Operand(),t,n.Copy());return null!=r?null!=s?r.Combine(s):r:null!=s?s:null}if(l===Node.Type.TEXT){const l=e;let r;return r=t&Mode.SEQUENCE?t&Mode.NOT?this.Not_Sequence(l,t,n):this.Sequence(l,t,n):t&Mode.NOT?this.Not_Text(l,t,n):this.Text(l,t,n),null!=r?this.Step(l.Next(),t,r):null}return l===Node.Type.END?n:(Utils.Assert(!1,`Unknown node_type: ${l}`),null)}Text(e,t,n){const l=n.Line(),r=e.Line();let s=!1;for(let e=0,o=l.Macro_Part_Count();e<o;e+=1)if(t&Mode.META||!l.Macro_Part(e).Is_Command()){let i=0,u=-1,a=-1;for(let p=0,h=r.Macro_Part_Count();p<h;p+=1){if(!(t&Mode.META))for(;e+i+p<o&&l.Macro_Part(e+i+p).Is_Command();)i+=1;if(!(e+i+p<o))break;{const o=l.Macro_Part(e+i+p),c=r.Macro_Part(p),{search_value:d,expression_value:N}=t&Mode.CASE?{search_value:o.Value(),expression_value:c.Value()}:{search_value:o.Value().toLowerCase(),expression_value:c.Value().toLowerCase()};let f;if(t&Mode.ALIGN)f=d===N,u=0,a=d.length;else if(h>1)if(0===p)if(d.length>=N.length&&d.slice(d.length-N.length,d.length)===N){f=!0,u=d.length-N.length;for(let e=u,t=0;e>t+(N.length-1)&&d.slice(e-N.length,e)===N;)e-=N.length,u=e}else f=!1;else if(p===h-1)if(d.length>=N.length&&d.slice(0,N.length)===N){f=!0,a=N.length;for(let e=a,t=d.length;e<t-(N.length-1)&&d.slice(e,e+N.length)===N;)e+=N.length,a=e}else f=!1;else f=d===N;else{f=!1;for(let e=0,t=d.length;e<t-(N.length-1);)if(f){if(d.slice(e,e+N.length)!==N)break;e+=N.length,a=e}else d.slice(e,e+N.length)===N?(f=!0,u=e,e+=N.length,a=e):e+=1}if(!f)break;p===h-1&&(s=!0,n.Try_Add_Match(new Result.Match({first_part_index:e,end_part_index:e+i+h,first_part_first_unit_index:u,last_part_end_unit_index:a})))}}}return s?n:null}Not_Text(e,t,n){return null==this.Text(e,t,n)?n:null}Sequence(e,t,n){return Utils.Assert(!1,"Not implemented yet."),null}Not_Sequence(e,t,n){return Utils.Assert(!1,"Not implemented yet."),null}}