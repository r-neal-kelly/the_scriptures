import*as Unicode from"../../unicode.js";import*as Text from"../text.js";import{Operator}from"./operator.js";import*as Token from"./token.js";export class Help{constructor(e,r){this.message=e.replace(/\r?\n/g," ").replace(/\s+/g," "),this.expression_index=r}Message(){return this.message}Expression_Index(){return this.expression_index}}export class Instance{constructor(){}Parse(e,r){const n=[];let p=0,t=0,o=0,O=!1;function a(){return n.length>0?n[n.length-1]:null}function l(){const e=a();null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||(O=!1,n.push(new Token.And))}let T=new Unicode.Iterator({text:e});for(;!T.Is_At_End();T=T.Next()){const i=T.Point();if(!/\s/.test(i))if(i===Operator.VERBATIM){if(l(),T=T.Next(),T.Is_At_End())return new Help(`Unclosed '${Operator.VERBATIM}'.`,T.Previous().Index());{const t=T;for(;!T.Is_At_End()&&T.Point()!==Operator.VERBATIM;T=T.Next());if(T.Is_At_End())return new Help(`Unclosed '${Operator.VERBATIM}'.`,T.Previous().Index());{const a=new Text.Instance({dictionary:r,value:e.slice(t.Index(),T.Index())});if(a.Line_Count()>1)return new Help(`Newline inside '${Operator.VERBATIM}'.`,T.Index());if(0===a.Line(0).Macro_Part_Count())return new Help(`Empty '${Operator.VERBATIM}'.`,T.Index());p=T.Index(),n.push(new Token.Text({line:a.Line(0),is_in_sequence:o>0,has_start_boundary_in_sequence:O}))}}}else if(i===Operator.OPEN_GROUP)l(),p=T.Index(),t+=1,n.push(new Token.Open_Group);else if(i===Operator.CLOSE_GROUP){const e=a();if(null==e)return new Help(`Invalid '${Operator.CLOSE_GROUP}' at beginning.`,T.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Empty '${Operator.OPEN_GROUP}${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.OPEN_SEQUENCE}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.NOT}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.CASE}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.ALIGN}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(t<1)return new Help(`Extra '${Operator.CLOSE_GROUP}'.`,T.Index());p=T.Index(),t-=1,n.push(new Token.Close_Group)}else if(i===Operator.OPEN_SEQUENCE){if(o>0)return new Help(`Interior '${Operator.OPEN_SEQUENCE}' within sequence.`,p);l(),p=T.Index(),o+=1,O=!0,n.push(new Token.Open_Sequence)}else if(i===Operator.CLOSE_SEQUENCE){const e=a();if(null===e)return new Help(`Invalid '${Operator.CLOSE_SEQUENCE}' at beginning.`,T.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.OPEN_GROUP}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Empty '${Operator.OPEN_SEQUENCE}${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.CLOSE_SEQUENCE)return new Help(`Invalid '${Operator.CLOSE_SEQUENCE}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.NOT}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.CASE}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.ALIGN}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(o<1)return new Help(`Extra '${Operator.CLOSE_SEQUENCE}'.`,T.Index());p=T.Index(),o-=1,O=!1,n.push(new Token.Close_Sequence)}else if(i===Operator.NOT)l(),p=T.Index(),n.push(new Token.Not);else if(i===Operator.CASE)l(),p=T.Index(),n.push(new Token.Case);else if(i===Operator.ALIGN)l(),p=T.Index(),n.push(new Token.Align);else if(i===Operator.AND){const e=a();if(null===e)return new Help(`Invalid '${Operator.AND}' at beginning.`,T.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.AND}' after '${Operator.OPEN_GROUP}'.`,T.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.AND}' after '${Operator.OPEN_SEQUENCE}'.`,T.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.AND}' after '${Operator.NOT}'.`,T.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.AND}' after '${Operator.CASE}'.`,T.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.AND}' after '${Operator.ALIGN}'.`,T.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' after '${Operator.AND}'.`,T.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.AND}' after '${Operator.XOR}'.`,T.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.AND}' after '${Operator.OR}'.`,T.Index());p=T.Index(),O=!1,n.push(new Token.And)}else if(i===Operator.XOR){const e=a();if(null===e)return new Help(`Invalid '${Operator.XOR}' at beginning.`,T.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.XOR}' after '${Operator.OPEN_GROUP}'.`,T.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.XOR}' after '${Operator.OPEN_SEQUENCE}'.`,T.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.XOR}' after '${Operator.NOT}'.`,T.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.XOR}' after '${Operator.CASE}'.`,T.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.XOR}' after '${Operator.ALIGN}'.`,T.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.XOR}' after '${Operator.AND}'.`,T.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' after '${Operator.XOR}'.`,T.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.XOR}' after '${Operator.OR}'.`,T.Index());p=T.Index(),n.push(new Token.Xor)}else if(i===Operator.OR){const e=a();if(null===e)return new Help(`Invalid '${Operator.OR}' at beginning.`,T.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.OR}' after '${Operator.OPEN_GROUP}'.`,T.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.OR}' after '${Operator.OPEN_SEQUENCE}'.`,T.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.OR}' after '${Operator.NOT}'.`,T.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.OR}' after '${Operator.CASE}'.`,T.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.OR}' after '${Operator.ALIGN}'.`,T.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.OR}' after '${Operator.AND}'.`,T.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.OR}' after '${Operator.XOR}'.`,T.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' after '${Operator.OR}'.`,T.Index());p=T.Index(),n.push(new Token.Or)}else{l();const t=T;for(T=T.Next();!T.Is_At_End()&&!/\s/.test(T.Point());T=T.Next());const a=new Text.Instance({dictionary:r,value:e.slice(t.Index(),T.Index())});p=t.Index(),n.push(new Token.Text({line:a.Line(0),is_in_sequence:o>0,has_start_boundary_in_sequence:O}))}}if(n.length<1)return new Help("Empty expression.",0);if(t>0)return new Help(`Unclosed '${Operator.OPEN_GROUP}'.`,T.Previous().Index());if(o>0)return new Help(`Unclosed '${Operator.OPEN_SEQUENCE}'.`,T.Previous().Index());{const e=n[n.length-1];if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.OPEN_GROUP}' at end.`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.OPEN_SEQUENCE}' at end.`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.NOT}' at end.`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.CASE}' at end.`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.ALIGN}' at end.`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' at end.`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' at end.`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' at end.`,p)}return n}}