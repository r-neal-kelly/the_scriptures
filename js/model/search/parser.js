import*as Unicode from"../../unicode.js";import{Operator}from"./operator.js";import*as Token from"./token.js";export class Help{constructor(e,n){this.message=e.replace(/\r?\n/g," ").replace(/\s+/g," "),this.expression_index=n}Message(){return this.message}Expression_Index(){return this.expression_index}}export class Instance{constructor(){}Tokenize(e){function n(e){return e.length>0?e[e.length-1]:null}const r=[];let p=0,o=0,t=0,O=new Unicode.Iterator({text:e});for(;!O.Is_At_End();O=O.Next()){const T=O.Point();if(!/\s/.test(T))if(T===Operator.VERBATIM){const o=n(r);if(null==o||o.Type()!==Token.Type.CLOSE_GROUP&&o.Type()!==Token.Type.CLOSE_SEQUENCE&&o.Type()!==Token.Type.TEXT||r.push(new Token.And),O=O.Next(),O.Is_At_End())return new Help(`Unclosed '${Operator.VERBATIM}'.`,O.Previous().Index());{const n=O;for(;!O.Is_At_End()&&O.Point()!==Operator.VERBATIM;O=O.Next());if(O.Is_At_End())return new Help(`Unclosed '${Operator.VERBATIM}'.`,O.Previous().Index());p=O.Index(),r.push(new Token.Text(e.slice(n.Index(),O.Index())))}}else if(T===Operator.OPEN_GROUP){const e=n(r);null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||r.push(new Token.And),p=O.Index(),o+=1,r.push(new Token.Open_Group)}else if(T===Operator.CLOSE_GROUP){const e=n(r);if(null==e)return new Help(`Invalid '${Operator.CLOSE_GROUP}' at beginning.`,O.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Empty '${Operator.OPEN_GROUP}${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.OPEN_SEQUENCE}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.NOT}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.CASE}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.ALIGN}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' followed by '${Operator.CLOSE_GROUP}'.`,p);if(o<1)return new Help(`Extra '${Operator.CLOSE_GROUP}'.`,O.Index());p=O.Index(),o-=1,r.push(new Token.Close_Group)}else if(T===Operator.OPEN_SEQUENCE){if(t>0)return new Help(`Interior '${Operator.OPEN_SEQUENCE}' within sequence.`,p);{const e=n(r);null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||r.push(new Token.And),p=O.Index(),t+=1,r.push(new Token.Open_Sequence)}}else if(T===Operator.CLOSE_SEQUENCE){const e=n(r);if(null===e)return new Help(`Invalid '${Operator.CLOSE_SEQUENCE}' at beginning.`,O.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.OPEN_GROUP}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Empty '${Operator.OPEN_SEQUENCE}${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.CLOSE_SEQUENCE)return new Help(`Invalid '${Operator.CLOSE_SEQUENCE}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.NOT}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.CASE}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.ALIGN}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' followed by '${Operator.CLOSE_SEQUENCE}'.`,p);if(t<1)return new Help(`Extra '${Operator.CLOSE_SEQUENCE}'.`,O.Index());p=O.Index(),t-=1,r.push(new Token.Close_Sequence)}else if(T===Operator.NOT){const e=n(r);null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||r.push(new Token.And),p=O.Index(),r.push(new Token.Not)}else if(T===Operator.CASE){const e=n(r);null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||r.push(new Token.And),p=O.Index(),r.push(new Token.Case)}else if(T===Operator.ALIGN){const e=n(r);null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||r.push(new Token.And),p=O.Index(),r.push(new Token.Align)}else if(T===Operator.AND){const e=n(r);if(null===e)return new Help(`Invalid '${Operator.AND}' at beginning.`,O.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.AND}' after '${Operator.OPEN_GROUP}'.`,O.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.AND}' after '${Operator.OPEN_SEQUENCE}'.`,O.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.AND}' after '${Operator.NOT}'.`,O.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.AND}' after '${Operator.CASE}'.`,O.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.AND}' after '${Operator.ALIGN}'.`,O.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' after '${Operator.AND}'.`,O.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.AND}' after '${Operator.XOR}'.`,O.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.AND}' after '${Operator.OR}'.`,O.Index());p=O.Index(),r.push(new Token.And)}else if(T===Operator.XOR){const e=n(r);if(null===e)return new Help(`Invalid '${Operator.XOR}' at beginning.`,O.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.XOR}' after '${Operator.OPEN_GROUP}'.`,O.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.XOR}' after '${Operator.OPEN_SEQUENCE}'.`,O.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.XOR}' after '${Operator.NOT}'.`,O.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.XOR}' after '${Operator.CASE}'.`,O.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.XOR}' after '${Operator.ALIGN}'.`,O.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.XOR}' after '${Operator.AND}'.`,O.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' after '${Operator.XOR}'.`,O.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.XOR}' after '${Operator.OR}'.`,O.Index());p=O.Index(),r.push(new Token.Xor)}else if(T===Operator.OR){const e=n(r);if(null===e)return new Help(`Invalid '${Operator.OR}' at beginning.`,O.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.OR}' after '${Operator.OPEN_GROUP}'.`,O.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.OR}' after '${Operator.OPEN_SEQUENCE}'.`,O.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.OR}' after '${Operator.NOT}'.`,O.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.OR}' after '${Operator.CASE}'.`,O.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.OR}' after '${Operator.ALIGN}'.`,O.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.OR}' after '${Operator.AND}'.`,O.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.OR}' after '${Operator.XOR}'.`,O.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' after '${Operator.OR}'.`,O.Index());p=O.Index(),r.push(new Token.Or)}else{const o=n(r);null==o||o.Type()!==Token.Type.CLOSE_GROUP&&o.Type()!==Token.Type.CLOSE_SEQUENCE&&o.Type()!==Token.Type.TEXT||r.push(new Token.And);const t=O;for(O=O.Next();!O.Is_At_End()&&!/\s/.test(O.Point());O=O.Next());p=t.Index(),r.push(new Token.Text(e.slice(t.Index(),O.Index())))}}if(r.length<1)return new Help("Empty expression.",0);if(o>0)return new Help(`Unclosed '${Operator.OPEN_GROUP}'.`,O.Previous().Index());if(t>0)return new Help(`Unclosed '${Operator.OPEN_SEQUENCE}'.`,O.Previous().Index());{const e=r[r.length-1];if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid '${Operator.OPEN_GROUP}' at end.`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid '${Operator.OPEN_SEQUENCE}' at end.`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid '${Operator.NOT}' at end.`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid '${Operator.CASE}' at end.`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid '${Operator.ALIGN}' at end.`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid '${Operator.AND}' at end.`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid '${Operator.XOR}' at end.`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid '${Operator.OR}' at end.`,p)}return r}}