import*as Unicode from"../../unicode.js";import*as Text from"../text.js";import{Operator}from"./operator.js";import{Boundary}from"./boundary.js";import*as Token from"./token.js";export class Help{constructor(e,r){this.message=e.replace(/\r?\n/g," ").replace(/\s+/g," "),this.expression_index=r}Message(){return this.message}Expression_Index(){return this.expression_index}}export class Instance{constructor(){}Parse(e,r){const n=[];let p=0,o=0,t=0,O=0,T=[];function a(){return n.length>0?n[n.length-1]:null}function l(){const e=a();null==e||e.Type()!==Token.Type.CLOSE_GROUP&&e.Type()!==Token.Type.CLOSE_SEQUENCE&&e.Type()!==Token.Type.TEXT||(t>0&&(T[T.length-1]+=1),n.push(new Token.And))}function E(e){if(t<1){t+=1,T.push(0),n.push(new Token.Open_Sequence({is_complex:!1}));for(let r=0,p=e.Line(0).Macro_Part_Count();r<p;r+=1)n.push(new Token.Text({part:e.Line(0).Macro_Part(r)})),r<p-1&&(T[T.length-1]+=1,n.push(new Token.And));i(),t-=1,n.push(new Token.Close_Sequence({is_complex:!1}))}else for(let r=0,p=e.Line(0).Macro_Part_Count();r<p;r+=1)n.push(new Token.Text({part:e.Line(0).Macro_Part(r)})),r<p-1&&(T[T.length-1]+=1,n.push(new Token.And))}function i(){let e=n.length;let r=0;for(;T.length>0;){let p=T.pop();if(p>0){const o=p>1;for(;e>0;)if(e-=1,n[e].Type()===Token.Type.CLOSE_GROUP)r+=1;else if(n[e].Type()===Token.Type.OPEN_GROUP)r-=1;else{if(n[e].Type()===Token.Type.AND){p-=1;break}n[e].Type()===Token.Type.TEXT&&n[e].Set_Boundary(Boundary.END)}if(o)for(;e>0;)if(e-=1,n[e].Type()===Token.Type.CLOSE_GROUP)r+=1;else if(n[e].Type()===Token.Type.OPEN_GROUP)r-=1;else if(n[e].Type()===Token.Type.AND){if(p-=1,0===p)break}else n[e].Type()===Token.Type.TEXT&&n[e].Set_Boundary(Boundary.MIDDLE);for(;e>0;)if(e-=1,n[e].Type()===Token.Type.CLOSE_GROUP)r+=1;else if(n[e].Type()===Token.Type.OPEN_GROUP)r-=1;else{if(n[e].Type()===Token.Type.OPEN_SEQUENCE||0===r&&(n[e].Type()===Token.Type.XOR||n[e].Type()===Token.Type.OR))break;n[e].Type()===Token.Type.TEXT&&n[e].Set_Boundary(Boundary.START)}}else for(;e>0;)if(e-=1,n[e].Type()===Token.Type.CLOSE_GROUP)r+=1;else if(n[e].Type()===Token.Type.OPEN_GROUP)r-=1;else{if(n[e].Type()===Token.Type.OPEN_SEQUENCE||0===r&&(n[e].Type()===Token.Type.XOR||n[e].Type()===Token.Type.OR))break;n[e].Type()===Token.Type.TEXT&&n[e].Set_Boundary(Boundary.ANY)}}}let y=new Unicode.Iterator({text:e});for(;!y.Is_At_End();y=y.Next()){const d=y.Point();if(!/\s/.test(d))if(d===Operator.VERBATIM){if(l(),y=y.Next(),y.Is_At_End())return new Help(`Unclosed ${Operator.VERBATIM}`,y.Previous().Index());{const n=y;for(;!y.Is_At_End()&&y.Point()!==Operator.VERBATIM;y=y.Next());if(y.Is_At_End())return new Help(`Unclosed ${Operator.VERBATIM}`,y.Previous().Index());{const o=new Text.Instance({dictionary:r,value:e.slice(n.Index(),y.Index())});if(o.Line_Count()>1)return new Help(`Newline inside ${Operator.VERBATIM}`,y.Index());if(0===o.Line(0).Macro_Part_Count())return new Help(`Empty ${Operator.VERBATIM}`,y.Index());p=y.Index(),E(o)}}}else if(d===Operator.OPEN_GROUP)l(),p=y.Index(),o+=1,t>0&&(O+=1),n.push(new Token.Open_Group);else if(d===Operator.CLOSE_GROUP){const e=a();if(null==e)return new Help(`Invalid ${Operator.CLOSE_GROUP} at beginning`,y.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Empty ${Operator.OPEN_GROUP}${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid ${Operator.OPEN_SEQUENCE} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid ${Operator.NOT} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid ${Operator.CASE} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid ${Operator.ALIGN} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.META)return new Help(`Invalid ${Operator.META} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid ${Operator.AND} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid ${Operator.XOR} followed by ${Operator.CLOSE_GROUP}`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid ${Operator.OR} followed by ${Operator.CLOSE_GROUP}`,p);if(o<1)return new Help(`Extra ${Operator.CLOSE_GROUP}`,y.Index());p=y.Index(),o-=1,t>0&&(O-=1),n.push(new Token.Close_Group)}else if(d===Operator.OPEN_SEQUENCE){if(t>0)return new Help(`Interior ${Operator.OPEN_SEQUENCE} within sequence`,p);l(),p=y.Index(),t+=1,T.push(0),n.push(new Token.Open_Sequence({is_complex:!0}))}else if(d===Operator.CLOSE_SEQUENCE){const e=a();if(null===e)return new Help(`Invalid ${Operator.CLOSE_SEQUENCE} at beginning`,y.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid ${Operator.OPEN_GROUP} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Empty ${Operator.OPEN_SEQUENCE}${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.CLOSE_SEQUENCE)return new Help(`Invalid ${Operator.CLOSE_SEQUENCE} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid ${Operator.NOT} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid ${Operator.CASE} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid ${Operator.ALIGN} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.META)return new Help(`Invalid ${Operator.META} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid ${Operator.AND} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid ${Operator.XOR} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid ${Operator.OR} followed by ${Operator.CLOSE_SEQUENCE}`,p);if(t<1)return new Help(`Extra ${Operator.CLOSE_SEQUENCE}`,y.Index());i(),p=y.Index(),t-=1,n.push(new Token.Close_Sequence({is_complex:!0}))}else if(d===Operator.NOT)l(),p=y.Index(),n.push(new Token.Not);else if(d===Operator.CASE)l(),p=y.Index(),n.push(new Token.Case);else if(d===Operator.ALIGN)l(),p=y.Index(),n.push(new Token.Align);else if(d===Operator.META)l(),p=y.Index(),n.push(new Token.Meta);else if(d===Operator.AND){const e=a();if(null===e)return new Help(`Invalid ${Operator.AND} at beginning`,y.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid ${Operator.AND} after ${Operator.OPEN_GROUP}`,y.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid ${Operator.AND} after ${Operator.OPEN_SEQUENCE}`,y.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid ${Operator.AND} after ${Operator.NOT}`,y.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid ${Operator.AND} after ${Operator.CASE}`,y.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid ${Operator.AND} after ${Operator.ALIGN}`,y.Index());if(e.Type()===Token.Type.META)return new Help(`Invalid ${Operator.AND} after ${Operator.META}`,y.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid ${Operator.AND} after ${Operator.AND}`,y.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid ${Operator.AND} after ${Operator.XOR}`,y.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid ${Operator.AND} after ${Operator.OR}`,y.Index());p=y.Index(),t>0&&(T[T.length-1]+=1),n.push(new Token.And)}else if(d===Operator.XOR){const e=a();if(null===e)return new Help(`Invalid ${Operator.XOR} at beginning`,y.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid ${Operator.XOR} after ${Operator.OPEN_GROUP}`,y.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid ${Operator.XOR} after ${Operator.OPEN_SEQUENCE}`,y.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid ${Operator.XOR} after ${Operator.NOT}`,y.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid ${Operator.XOR} after ${Operator.CASE}`,y.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid ${Operator.XOR} after ${Operator.ALIGN}`,y.Index());if(e.Type()===Token.Type.META)return new Help(`Invalid ${Operator.XOR} after ${Operator.META}`,y.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid ${Operator.XOR} after ${Operator.AND}`,y.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid ${Operator.XOR} after ${Operator.XOR}`,y.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid ${Operator.XOR} after ${Operator.OR}`,y.Index());p=y.Index(),t>0&&0===O&&T.push(0),n.push(new Token.Xor)}else if(d===Operator.OR){const e=a();if(null===e)return new Help(`Invalid ${Operator.OR} at beginning`,y.Index());if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid ${Operator.OR} after ${Operator.OPEN_GROUP}`,y.Index());if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid ${Operator.OR} after ${Operator.OPEN_SEQUENCE}`,y.Index());if(e.Type()===Token.Type.NOT)return new Help(`Invalid ${Operator.OR} after ${Operator.NOT}`,y.Index());if(e.Type()===Token.Type.CASE)return new Help(`Invalid ${Operator.OR} after ${Operator.CASE}`,y.Index());if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid ${Operator.OR} after ${Operator.ALIGN}`,y.Index());if(e.Type()===Token.Type.META)return new Help(`Invalid ${Operator.OR} after ${Operator.META}`,y.Index());if(e.Type()===Token.Type.AND)return new Help(`Invalid ${Operator.OR} after ${Operator.AND}`,y.Index());if(e.Type()===Token.Type.XOR)return new Help(`Invalid ${Operator.OR} after ${Operator.XOR}`,y.Index());if(e.Type()===Token.Type.OR)return new Help(`Invalid ${Operator.OR} after ${Operator.OR}`,y.Index());p=y.Index(),t>0&&0===O&&T.push(0),n.push(new Token.Or)}else{l();const n=y;for(y=y.Next();!y.Is_At_End();y=y.Next()){const e=y.Point();if(/\s/.test(e)||e===Operator.VERBATIM||e===Operator.OPEN_GROUP||e===Operator.CLOSE_GROUP||e===Operator.OPEN_SEQUENCE||e===Operator.CLOSE_SEQUENCE||e===Operator.NOT||e===Operator.CASE||e===Operator.ALIGN||e===Operator.META||e===Operator.AND||e===Operator.XOR||e===Operator.OR)break}const o=new Text.Instance({dictionary:r,value:e.slice(n.Index(),y.Index())});y=y.Previous(),p=n.Index(),E(o)}}if(n.length<1)return new Help("Empty expression",0);if(o>0)return new Help(`Unclosed ${Operator.OPEN_GROUP}`,y.Previous().Index());if(t>0)return new Help(`Unclosed ${Operator.OPEN_SEQUENCE}`,y.Previous().Index());{const e=n[n.length-1];if(e.Type()===Token.Type.OPEN_GROUP)return new Help(`Invalid ${Operator.OPEN_GROUP} at end`,p);if(e.Type()===Token.Type.OPEN_SEQUENCE)return new Help(`Invalid ${Operator.OPEN_SEQUENCE} at end`,p);if(e.Type()===Token.Type.NOT)return new Help(`Invalid ${Operator.NOT} at end`,p);if(e.Type()===Token.Type.CASE)return new Help(`Invalid ${Operator.CASE} at end`,p);if(e.Type()===Token.Type.ALIGN)return new Help(`Invalid ${Operator.ALIGN} at end`,p);if(e.Type()===Token.Type.META)return new Help(`Invalid ${Operator.META} at end`,p);if(e.Type()===Token.Type.AND)return new Help(`Invalid ${Operator.AND} at end`,p);if(e.Type()===Token.Type.XOR)return new Help(`Invalid ${Operator.XOR} at end`,p);if(e.Type()===Token.Type.OR)return new Help(`Invalid ${Operator.OR} at end`,p)}return n}}