import*as Utils from"../../utils.js";export var Type;!function(e){e[e.TEXT=0]="TEXT",e[e.CLASS=1]="CLASS",e[e.OR=2]="OR",e[e.XOR=3]="XOR",e[e.NOT=4]="NOT",e[e.CASE=5]="CASE",e[e.ALIGN=6]="ALIGN",e[e.META=7]="META",e[e.SEQUENCE=8]="SEQUENCE",e[e.MAYBE_ONE=9]="MAYBE_ONE",e[e.MAYBE_MANY=10]="MAYBE_MANY",e[e.ONE_OR_MANY=11]="ONE_OR_MANY",e[e.END=12]="END"}(Type||(Type={}));export class Instance{constructor({type:e}){this.type=e,this.next=null}Type(){return this.type}Next(){return  this.next}Set_Next(e){this.next=e,Object.freeze(this)}}export class Text extends Instance{constructor({token:e}){super({type:Type.TEXT}),this.token=e}Token(){return this.token}Part(){return this.Token().Part()}}export class Class extends Instance{constructor({token:e}){super({type:Type.CLASS}),this.token=e}Token(){return this.token}Value(){return this.Token().Value()}Recognizes(e){return this.Value().Recognizes(e)}}export class Binary extends Instance{constructor({type:e,left_operand:t,right_operand:r}){super({type:e}),this.right_operand=r,super.Set_Next(t)}Next(){return  END}Set_Next(e){}Left_Operand(){return super.Next()}Right_Operand(){return this.right_operand}}export class Or extends Binary{constructor({left_operand:e,right_operand:t}){super({type:Type.OR,left_operand:e,right_operand:t})}}export class Xor extends Binary{constructor({left_operand:e,right_operand:t}){super({type:Type.XOR,left_operand:e,right_operand:t})}}export class Unary extends Instance{constructor({type:e,operand:t}){super({type:e}),this.operand=t}Operand(){return this.operand}}export class Not extends Unary{constructor({operand:e}){super({type:Type.NOT,operand:e})}}export class Case extends Unary{constructor({operand:e}){super({type:Type.CASE,operand:e})}}export class Align extends Unary{constructor({operand:e}){super({type:Type.ALIGN,operand:e})}}export class Meta extends Unary{constructor({operand:e}){super({type:Type.META,operand:e})}}export class Sequence extends Unary{constructor({operand:e,token:t}){super({type:Type.SEQUENCE,operand:e}),this.token=t}Token(){return this.token}Sequence_Type(){return this.Token().Sequence_Type()}}export class Maybe_One extends Unary{constructor({operand:e}){super({type:Type.MAYBE_ONE,operand:e})}}export class Maybe_Many extends Unary{constructor({operand:e}){super({type:Type.MAYBE_MANY,operand:e})}}export class One_Or_Many extends Unary{constructor({operand:e}){super({type:Type.ONE_OR_MANY,operand:e})}}export class End extends Instance{constructor(){super({type:Type.END})}Next(){return  END}Set_Next(e){}}export const END=new End;