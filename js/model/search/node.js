import*as Utils from"../../utils.js";export var Type;!function(e){e[e.TEXT=0]="TEXT",e[e.OR=1]="OR",e[e.XOR=2]="XOR",e[e.NOT=3]="NOT",e[e.CASE=4]="CASE",e[e.ALIGN=5]="ALIGN",e[e.SEQUENCE=6]="SEQUENCE",e[e.END=7]="END"}(Type||(Type={}));export class Instance{constructor({type:e}){this.type=e,this.next=null}Type(){return this.type}Next(){return Utils.Assert(null!=this.next,"Internal compiler error, next is null!"),this.next}Set_Next(e){this.next=e,Object.freeze(this)}}export class Text extends Instance{constructor({token:e}){super({type:Type.TEXT}),this.token=e}Token(){return this.token}Line(){return this.Token().Line()}Is_In_Sequence(){return this.Token().Is_In_Sequence()}Has_Start_Boundary_In_Sequence(){return this.Is_In_Sequence()&&this.Token().Has_Start_Boundary_In_Sequence()}Has_Middle_Boundary_In_Sequence(){return this.Is_In_Sequence()&&!this.Has_Start_Boundary_In_Sequence()&&!this.Has_End_Boundary_In_Sequence()}Has_End_Boundary_In_Sequence(){return this.Is_In_Sequence()&&this.Next()===END}May_Have_Implicit_Word_In_Sequence(){return this.Is_In_Sequence()&&1===this.Line().Macro_Part_Count()&&this.Line().Macro_Part(0).Is_Break()}May_Have_Implicit_Break_In_Sequence(){return this.Is_In_Sequence()&&1===this.Line().Macro_Part_Count()&&this.Line().Macro_Part(0).Is_Word()}}export class Binary extends Instance{constructor({type:e,left_operand:t,right_operand:n}){super({type:e}),super.Set_Next(t),this.right_operand=n,Object.freeze(this)}Next(){return Utils.Assert(!1,"Unused method."),END}Set_Next(e){Utils.Assert(!1,"Unused method.")}Left_Operand(){return this.Next()}Right_Operand(){return this.right_operand}}export class Or extends Binary{constructor({left_operand:e,right_operand:t}){super({type:Type.OR,left_operand:e,right_operand:t})}}export class Xor extends Binary{constructor({left_operand:e,right_operand:t}){super({type:Type.XOR,left_operand:e,right_operand:t})}}export class Unary extends Instance{constructor({type:e,operand:t}){super({type:e}),this.operand=t}Operand(){return this.operand}}export class Not extends Unary{constructor({operand:e}){super({type:Type.NOT,operand:e})}}export class Case extends Unary{constructor({operand:e}){super({type:Type.CASE,operand:e})}}export class Align extends Unary{constructor({operand:e}){super({type:Type.ALIGN,operand:e})}}export class Sequence extends Unary{constructor({operand:e}){super({type:Type.SEQUENCE,operand:e})}}export class End extends Instance{constructor(){super({type:Type.END})}Next(){return Utils.Assert(!1,"Unused method."),END}Set_Next(e){Utils.Assert(!1,"Unused method.")}}export const END=new End;