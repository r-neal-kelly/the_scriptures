import*as Utils from"../../utils.js";export var Type;!function(e){e[e.TEXT=0]="TEXT",e[e.OR=1]="OR",e[e.XOR=2]="XOR",e[e.NOT=3]="NOT",e[e.CASE=4]="CASE",e[e.ALIGN=5]="ALIGN",e[e.META=6]="META",e[e.SEQUENCE=7]="SEQUENCE",e[e.END=8]="END"}(Type||(Type={}));export class Instance{constructor({type:e}){this.type=e,this.next=null}Type(){return this.type}Next(){return Utils.Assert(null!=this.next,"Internal compiler error, next is null!"),this.next}Set_Next(e){this.next=e,Object.freeze(this)}}export class Text extends Instance{constructor({token:e}){super({type:Type.TEXT}),this.token=e}Token(){return this.token}Part(){return this.Token().Part()}Boundary(){return this.Token().Boundary()}May_Precede_Implicit_Word_In_Sequence(){return this.Token().May_Precede_Implicit_Word_In_Sequence()}May_Precede_Implicit_Break_In_Sequence(){return this.Token().May_Precede_Implicit_Break_In_Sequence()}}export class Binary extends Instance{constructor({type:e,left_operand:t,right_operand:r}){super({type:e}),this.right_operand=r,super.Set_Next(t)}Next(){return Utils.Assert(!1,"Unused method."),END}Set_Next(e){Utils.Assert(!1,"Unused method.")}Left_Operand(){return super.Next()}Right_Operand(){return this.right_operand}}export class Or extends Binary{constructor({left_operand:e,right_operand:t}){super({type:Type.OR,left_operand:e,right_operand:t})}}export class Xor extends Binary{constructor({left_operand:e,right_operand:t}){super({type:Type.XOR,left_operand:e,right_operand:t})}}export class Unary extends Instance{constructor({type:e,operand:t}){super({type:e}),this.operand=t}Operand(){return this.operand}}export class Not extends Unary{constructor({operand:e}){super({type:Type.NOT,operand:e})}}export class Case extends Unary{constructor({operand:e}){super({type:Type.CASE,operand:e})}}export class Align extends Unary{constructor({operand:e}){super({type:Type.ALIGN,operand:e})}}export class Meta extends Unary{constructor({operand:e}){super({type:Type.META,operand:e})}}export class Sequence extends Unary{constructor({operand:e,token:t}){super({type:Type.SEQUENCE,operand:e}),this.token=t}Token(){return this.token}Is_Complex(){return this.Token().Is_Complex()}}export class End extends Instance{constructor(){super({type:Type.END})}Next(){return Utils.Assert(!1,"Unused method."),END}Set_Next(e){Utils.Assert(!1,"Unused method.")}}export const END=new End;