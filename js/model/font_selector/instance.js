var __awaiter=this&&this.__awaiter||function(t,s,e,o){return new(e||(e=Promise))((function(n,l){function _(t){try{r(o.next(t))}catch(t){l(t)}}function i(t){try{r(o.throw(t))}catch(t){l(t)}}function r(t){var s;t.done?n(t.value):(s=t.value,s instanceof e?s:new e((function(t){t(s)}))).then(_,i)}r((o=o.apply(t,s||[])).next())}))};import*as Utils from"../../utils.js";import*as Entity from"../entity.js";import*as Languages from"../languages.js";import*as Slot from"./slot.js";export class Instance extends Entity.Instance{static Max_Slot_Count(){return Instance.MAX_SLOT_COUNT}constructor(){super(),this.cached_font_slots={},this.slots=[],this.Add_Dependencies([])}Slot_Count(){return this.slots.length}Has_Slot(t){return this.slots.includes(t)}Has_Slot_Type(t){for(const s of this.slots)if(s.Type()===t)return!0;return!1}Slot_From_Type(t){for(const s of this.slots)if(s.Type()===t)return s;return Utils.Assert(!1,"Does not have slot with that type."),this.slots[0]}Has_Slot_At_Index(t){return Utils.Assert(t>-1,"slot_index must be greater than -1."),t<this.Slot_Count()}Slot_At_Index(t){return Utils.Assert(t>-1,"slot_index must be greater than -1."),Utils.Assert(t<this.Slot_Count(),"slot_index must be less than slot_count."),this.slots[t]}Slots(){return Array.from(this.slots)}Slot_Types(){return[Slot.Type.LANGUAGES,Slot.Type.FONTS]}Push_Slot(){const t=this.Slot_Count();Utils.Assert(t<Instance.Max_Slot_Count(),"All slots have been pushed already.");const s=t,e=this.Slot_Types()[s];e===Slot.Type.LANGUAGES?this.slots.push(new Slot.Instance({selector:this,index:s,type:e,item_names:Languages.Singleton().Language_Names()})):e===Slot.Type.FONTS?this.slots.push(this.Fonts(this.Slot_At_Index(0).Selected_Item().Name())):Utils.Assert(!1,"unknown slot_type")}Pop_Slot(){this.slots.pop()}Fonts(t){return Utils.Assert(this.cached_font_slots.hasOwnProperty(t),`does not have language_name: ${t}`),this.cached_font_slots[t]}Some_Selected_Font_Name(t){return Languages.Singleton().Short_Font_Name_To_Font_Name(t,this.Fonts(t).Selected_Item().Name())}__Select_Item__({slot:t,slot_item:s}){if(Utils.Assert(this.Has_Slot(t),"The slot does not belong to this selector."),t.__Select_Item__({item:s}),t.Type()!==Slot.Type.FONTS)if(this.Slot_At_Index(this.Slot_Count()-1)===t)this.Push_Slot();else{for(;this.Slot_Count()>t.Index()+1;)this.Pop_Slot();this.Push_Slot()}}After_Dependencies_Are_Ready(){return __awaiter(this,void 0,void 0,(function*(){const t=Languages.Singleton(),s=t.Language_Names();for(const e of s)this.cached_font_slots[e]=new Slot.Instance({selector:this,index:1,type:Slot.Type.FONTS,item_names:t.Global_Short_Font_Names(e),selected_item_name:t.Current_Global_Short_Font_Name(e)});this.Push_Slot()}))}}Instance.MAX_SLOT_COUNT=2;