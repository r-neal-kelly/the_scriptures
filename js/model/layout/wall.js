var __awaiter=this&&this.__awaiter||function(t,s,i,e){return new(i||(i=Promise))((function(n,a){function r(t){try{w(e.next(t))}catch(t){a(t)}}function o(t){try{w(e.throw(t))}catch(t){a(t)}}function w(t){var s;t.done?n(t.value):(s=t.value,s instanceof i?s:new i((function(t){t(s)}))).then(r,o)}w((e=e.apply(t,s||[])).next())}))};import*as Utils from"../../utils.js";import*as Entity from"../entity.js";import*as Window from"./window.js";export class Instance extends Entity.Instance{constructor({layout:t}){super(),this.layout=t,this.windows=new Map,this.Add_Dependencies([])}Layout(){return this.layout}Count(){return this.windows.size}Has(t){return this.Has_ID(t.ID())}Has_ID(t){return this.windows.has(t)}From_ID(t){return Utils.Assert(this.Has_ID(t),`Does not have window with id ${t}.`),this.windows.get(t)}Has_At(t){return this.Layout().Bar().Tabs().Has_At(t)}At(t){return Utils.Assert(this.Has_At(t),`Has no window at index ${t}.`),this.Layout().Bar().Tabs().At(t).Window()}Iterator(){return this.windows.values()}Array(){return Array.from(this.Iterator())}Add(t){const s=t.ID();Utils.Assert(!this.Has_ID(s),`Already has a window with id of ${s}.`),Utils.Assert(t.Is_Alive(),"A window must be alive to be added."),Utils.Assert(!t.Is_In_Wall(),"Window is already in a wall."),this.windows.set(s,t),this.Layout().Bar().Tabs().Add_Window(t)}Remove(t){Utils.Assert(this.Has_ID(t),`Doesn't have window with id of ${t}.`),Utils.Assert(this.From_ID(t).Is_Alive(),"A window must be alive to be removed."),Utils.Assert(this.From_ID(t).Wall()===this,"Window wall mismatch!"),this.Layout().Bar().Tabs().Remove_Window(this.From_ID(t)),this.windows.delete(t)}Add_Program(t){return __awaiter(this,void 0,void 0,(function*(){const s=new Window.Instance({wall:this,program:t});return yield s.Ready(),s.ID()}))}}