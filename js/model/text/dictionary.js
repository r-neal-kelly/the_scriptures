import*as Utils from"../../utils.js";import*as Unicode from"../../unicode.js";export var Boundary;!function(r){r.START="START",r.MIDDLE="MIDDLE",r.END="END"}(Boundary||(Boundary={}));export class Instance{constructor({json:r=null}={}){this.info=null!=r?JSON.parse(r):{letters:[],markers:[],words:{},breaks:{[Boundary.START]:{},[Boundary.MIDDLE]:{},[Boundary.END]:{}},word_errors:[],break_errors:{[Boundary.START]:[],[Boundary.MIDDLE]:[],[Boundary.END]:[]}}}Is_Valid(){for(const r of["letters","markers"]){if(!this.info.hasOwnProperty(r)||!Utils.Is.Array(this.info[r]))return!1;for(const s of this.info[r])if(!Utils.Is.String(s))return!1}if(!this.info.hasOwnProperty("words")||!Utils.Is.Object(this.info.words))return!1;for(const[r,s]of Object.entries(this.info.words)){if(!Utils.Is.String(r)||!Utils.Is.Array(s))return!1;for(const r of s)if(!Utils.Is.String(r))return!1}if(!this.info.hasOwnProperty("breaks")||!Utils.Is.Object(this.info.breaks))return!1;for(const r of[Boundary.START,Boundary.MIDDLE,Boundary.END]){if(!this.info.breaks.hasOwnProperty(r)||!Utils.Is.Object(this.info.breaks[r]))return!1;for(const[s,o]of Object.entries(this.info.breaks[r])){if(!Utils.Is.String(s)||!Utils.Is.Array(o))return!1;for(const r of o)if(!Utils.Is.String(r))return!1}}if(!this.info.hasOwnProperty("word_errors")||!Utils.Is.Array(this.info.word_errors))return!1;for(const r of this.info.word_errors)if(!Utils.Is.String(r))return!1;if(!this.info.hasOwnProperty("break_errors")||!Utils.Is.Object(this.info.break_errors))return!1;for(const r of[Boundary.START,Boundary.MIDDLE,Boundary.END]){if(!this.info.break_errors.hasOwnProperty(r)||!Utils.Is.Array(this.info.break_errors[r]))return!1;for(const s of this.info.break_errors[r])if(!Utils.Is.String(s))return!1}return!0}Validate(){for(const r of["letters","markers"]){0;for(const s of this.info[r])0}0;for(const[r,s]of Object.entries(this.info.words)){0;for(const r of s)0}0;for(const r of[Boundary.START,Boundary.MIDDLE,Boundary.END]){0;for(const[s,o]of Object.entries(this.info.breaks[r])){0;for(const r of o)0}}0;for(const r of this.info.word_errors)0;0;for(const r of[Boundary.START,Boundary.MIDDLE,Boundary.END]){0;for(const s of this.info.break_errors[r])0}}Has_Letter(r){return 0,this.info.letters.includes(r)}Add_Letter(r){0,this.info.letters.includes(r)||(this.info.letters.push(r),this.info.words[r]=[])}Remove_Letter(r){0;const s=this.info.letters.indexOf(r);s>-1&&(this.info.letters[s]=this.info.letters[this.info.letters.length-1],this.info.letters.pop(),delete this.info.words[r])}Has_Marker(r){return 0,this.info.markers.includes(r)}Add_Marker(r){0,this.info.markers.includes(r)||(this.info.markers.push(r),this.info.breaks[Boundary.START][r]=[],this.info.breaks[Boundary.MIDDLE][r]=[],this.info.breaks[Boundary.END][r]=[])}Remove_Marker(r){0;const s=this.info.markers.indexOf(r);s>-1&&(this.info.markers[s]=this.info.markers[this.info.markers.length-1],this.info.markers.pop(),delete this.info.breaks[Boundary.START][r],delete this.info.breaks[Boundary.MIDDLE][r],delete this.info.breaks[Boundary.END][r])}Has_Word(r){0;const s=Unicode.First_Point(r);return null!=this.info.words[s]&&this.info.words[s].includes(r)}Add_Word(r){0,0;const s=Unicode.First_Point(r);null==this.info.words[s]?(this.Add_Letter(s),this.info.words[s].push(r)):this.info.words[s].includes(r)||this.info.words[s].push(r)}Remove_Word(r){0;const s=Unicode.First_Point(r);if(null!=this.info.words[s]){const o=this.info.words[s].indexOf(r);o>-1&&(this.info.words[s][o]=this.info.words[s][this.info.words[s].length-1],this.info.words[s].pop())}}Has_Break(r,s){0;const o=Unicode.First_Point(r);return null!=this.info.breaks[s][o]&&this.info.breaks[s][o].includes(r)}Add_Break(r,s){0,0;const o=Unicode.First_Point(r);null==this.info.breaks[s][o]?(this.Add_Marker(o),this.info.breaks[s][o].push(r)):this.info.breaks[s][o].includes(r)||this.info.breaks[s][o].push(r)}Remove_Break(r,s){0;const o=Unicode.First_Point(r);if(null!=this.info.breaks[s][o]){const t=this.info.breaks[s][o].indexOf(r);t>-1&&(this.info.breaks[s][o][t]=this.info.breaks[s][o][this.info.breaks[s][o].length-1],this.info.breaks[s][o].pop())}}Has_Word_Error(r){return 0,this.info.word_errors.includes(r)}Add_Word_Error(r){0,0,this.info.word_errors.includes(r)||this.info.word_errors.push(r)}Remove_Word_Error(r){0;const s=this.info.word_errors.indexOf(r);s>-1&&(this.info.word_errors[s]=this.info.word_errors[this.info.word_errors.length-1],this.info.word_errors.pop())}Has_Break_Error(r,s){return 0,this.info.break_errors[s].includes(r)}Add_Break_Error(r,s){0,0,this.info.break_errors[s].includes(r)||this.info.break_errors[s].push(r)}Remove_Break_Error(r,s){0;const o=this.info.break_errors[s].indexOf(r);o>-1&&(this.info.break_errors[s][o]=this.info.break_errors[s][this.info.break_errors[s].length-1],this.info.break_errors[s].pop())}To_JSON(){this.info.letters.sort(),this.info.markers.sort();const r={};for(const s of Object.keys(this.info.words).sort())r[s]=this.info.words[s].sort();this.info.words=r;const s={[Boundary.START]:{},[Boundary.MIDDLE]:{},[Boundary.END]:{}};for(const r of[Boundary.START,Boundary.MIDDLE,Boundary.END])for(const o of Object.keys(this.info.breaks[r]).sort())s[r][o]=this.info.breaks[r][o].sort();this.info.breaks=s,this.info.word_errors.sort();for(const r of[Boundary.START,Boundary.MIDDLE,Boundary.END])this.info.break_errors[r].sort();return JSON.stringify(this.info)}Unique_Parts(){const r=new Set;for(const s of Object.values(this.info.words))for(const o of s)r.add(o);for(const s of Object.values(this.info.breaks[Boundary.START]))for(const o of s)r.add(o);for(const s of Object.values(this.info.breaks[Boundary.MIDDLE]))for(const o of s)r.add(o);for(const s of Object.values(this.info.breaks[Boundary.END]))for(const o of s)r.add(o);for(const s of this.info.word_errors)r.add(s);for(const s of this.info.break_errors[Boundary.START])r.add(s);for(const s of this.info.break_errors[Boundary.MIDDLE])r.add(s);for(const s of this.info.break_errors[Boundary.END])r.add(s);return Array.from(r).sort()}}