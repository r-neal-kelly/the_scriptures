import*as Utils from"../../utils.js";import*as Unicode from"../../unicode.js";export var Boundary;!function(s){s.START="START",s.MIDDLE="MIDDLE",s.END="END"}(Boundary||(Boundary={}));export class Instance{constructor({json:s=null}){this.info=null!=s?JSON.parse(s):{letters:[],markers:[],words:{},breaks:{[Boundary.START]:{},[Boundary.MIDDLE]:{},[Boundary.END]:{}},word_errors:[],break_errors:{[Boundary.START]:[],[Boundary.MIDDLE]:[],[Boundary.END]:[]}}}Validate(){for(const s of["letters","markers"]){0;for(const r of this.info[s])0}0;for(const[s,r]of Object.entries(this.info.words)){0;for(const s of r)0}0;for(const s of[Boundary.START,Boundary.MIDDLE,Boundary.END]){0;for(const[r,o]of Object.entries(this.info.breaks[s])){0;for(const s of o)0}}0;for(const s of this.info.word_errors)0;0;for(const s of[Boundary.START,Boundary.MIDDLE,Boundary.END]){0;for(const r of this.info.break_errors[s])0}}Has_Letter(s){return 0,this.info.letters.includes(s)}Add_Letter(s){0,this.info.letters.includes(s)||(this.info.letters.push(s),this.info.words[s]=[])}Remove_Letter(s){0;const r=this.info.letters.indexOf(s);r>-1&&(this.info.letters[r]=this.info.letters[this.info.letters.length-1],this.info.letters.pop(),delete this.info.words[s])}Has_Marker(s){return 0,this.info.markers.includes(s)}Add_Marker(s){0,this.info.markers.includes(s)||(this.info.markers.push(s),this.info.breaks[Boundary.START][s]=[],this.info.breaks[Boundary.MIDDLE][s]=[],this.info.breaks[Boundary.END][s]=[])}Remove_Marker(s){0;const r=this.info.markers.indexOf(s);r>-1&&(this.info.markers[r]=this.info.markers[this.info.markers.length-1],this.info.markers.pop(),delete this.info.breaks[Boundary.START][s],delete this.info.breaks[Boundary.MIDDLE][s],delete this.info.breaks[Boundary.END][s])}Has_Word(s){0;const r=Unicode.First_Point(s);return null!=this.info.words[r]&&this.info.words[r].includes(s)}Add_Word(s){0,0;const r=Unicode.First_Point(s);null==this.info.words[r]?(this.Add_Letter(r),this.info.words[r].push(s)):this.info.words[r].includes(s)||this.info.words[r].push(s)}Remove_Word(s){0;const r=Unicode.First_Point(s);if(null!=this.info.words[r]){const o=this.info.words[r].indexOf(s);o>-1&&(this.info.words[r][o]=this.info.words[r][this.info.words[r].length-1],this.info.words[r].pop())}}Has_Break(s,r){0;const o=Unicode.First_Point(s);return null!=this.info.breaks[r][o]&&this.info.breaks[r][o].includes(s)}Add_Break(s,r){0,0;const o=Unicode.First_Point(s);null==this.info.breaks[r][o]?(this.Add_Marker(o),this.info.breaks[r][o].push(s)):this.info.breaks[r][o].includes(s)||this.info.breaks[r][o].push(s)}Remove_Break(s,r){0;const o=Unicode.First_Point(s);if(null!=this.info.breaks[r][o]){const i=this.info.breaks[r][o].indexOf(s);i>-1&&(this.info.breaks[r][o][i]=this.info.breaks[r][o][this.info.breaks[r][o].length-1],this.info.breaks[r][o].pop())}}Has_Word_Error(s){return 0,this.info.word_errors.includes(s)}Add_Word_Error(s){0,0,this.info.word_errors.includes(s)||this.info.word_errors.push(s)}Remove_Word_Error(s){0;const r=this.info.word_errors.indexOf(s);r>-1&&(this.info.word_errors[r]=this.info.word_errors[this.info.word_errors.length-1],this.info.word_errors.pop())}Has_Break_Error(s,r){return 0,this.info.break_errors[r].includes(s)}Add_Break_Error(s,r){0,0,this.info.break_errors[r].includes(s)||this.info.break_errors[r].push(s)}Remove_Break_Error(s,r){0;const o=this.info.break_errors[r].indexOf(s);o>-1&&(this.info.break_errors[r][o]=this.info.break_errors[r][this.info.break_errors[r].length-1],this.info.break_errors[r].pop())}To_JSON(){this.info.letters.sort(),this.info.markers.sort();const s={};for(const r of Object.keys(this.info.words).sort())s[r]=this.info.words[r].sort();this.info.words=s;const r={[Boundary.START]:{},[Boundary.MIDDLE]:{},[Boundary.END]:{}};for(const s of[Boundary.START,Boundary.MIDDLE,Boundary.END])for(const o of Object.keys(this.info.breaks[s]).sort())r[s][o]=this.info.breaks[s][o].sort();this.info.breaks=r,this.info.word_errors.sort();for(const s of[Boundary.START,Boundary.MIDDLE,Boundary.END])this.info.break_errors[s].sort();return JSON.stringify(this.info)}Unique_Parts(){const s=new Set;for(const r of Object.values(this.info.words))for(const o of r)s.add(o);for(const r of Object.values(this.info.breaks[Boundary.START]))for(const o of r)s.add(o);for(const r of Object.values(this.info.breaks[Boundary.MIDDLE]))for(const o of r)s.add(o);for(const r of Object.values(this.info.breaks[Boundary.END]))for(const o of r)s.add(o);for(const r of this.info.word_errors)s.add(r);for(const r of this.info.break_errors[Boundary.START])s.add(r);for(const r of this.info.break_errors[Boundary.MIDDLE])s.add(r);for(const r of this.info.break_errors[Boundary.END])s.add(r);return Array.from(s).sort()}}