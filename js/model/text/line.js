import*as Utils from"../../utils.js";import*as Unicode from"../../unicode.js";import*as Dictionary from"./dictionary.js";import*as Part from"./part.js";import*as Split from"./split.js";import*as Segment from"./segment.js";export class Instance{constructor({text:t,index:e,value:s}){this.text=t,this.index=e,this.value="",this.micro_parts=[],this.macro_parts=[],this.micro_segments=[],this.macro_segments=[],this.micro_part_index_to_segment_item_indices={},this.macro_part_index_to_segment_item_indices={},this.is_centered=!1,this.is_indented=!1,this.Set_Value(s)}Text(){return this.text}Index(){return this.index}Value(){return this.value}Set_Value(t){let e;Utils.Assert(!/\r?\n/.test(t),"A line cannot have any line-breaks."),this.value=t,this.micro_parts=[],this.macro_parts=[],this.micro_segments=[],this.macro_segments=[],this.micro_part_index_to_segment_item_indices={},this.macro_part_index_to_segment_item_indices={},this.is_centered=this.value.slice(0,Part.Command.Known_Value.CENTER.length)===Part.Command.Known_Value.CENTER,this.is_indented=this.value.slice(0,Part.Command.Known_Value.INDENT.length)===Part.Command.Known_Value.INDENT,function(t){t[t.WORD=0]="WORD",t[t.BREAK=1]="BREAK",t[t.POINT=2]="POINT"}(e||(e={}));const s=this.Text().Dictionary();let n=Part.Style._NONE_,r=e.POINT,i=new Unicode.Iterator({text:this.value}),a=null;const _=Part.Command.Last_Non_Value_Index(this.value);let o=new Segment.Instance({segment_type:Segment.Type.MICRO,index:this.micro_segments.length}),m=new Segment.Instance({segment_type:Segment.Type.MACRO,index:this.macro_segments.length});const c=function(t){o.Try_Add_Item(t)||(this.micro_segments.push(o),o=new Segment.Instance({segment_type:Segment.Type.MICRO,index:this.micro_segments.length}),o.Add_Item(t));const e=t.Part_Index(),s={segment_index:o.Index(),item_index:o.Item_Count()-1};Object.freeze(s),null==this.micro_part_index_to_segment_item_indices[e]&&(this.micro_part_index_to_segment_item_indices[e]=[]),this.micro_part_index_to_segment_item_indices[e].push(s)}.bind(this),l=function(t){m.Try_Add_Item(t)||(this.macro_segments.push(m),m=new Segment.Instance({segment_type:Segment.Type.MACRO,index:this.macro_segments.length}),m.Add_Item(t));const e=t.Part_Index(),s={segment_index:m.Index(),item_index:m.Item_Count()-1};Object.freeze(s),null==this.macro_part_index_to_segment_item_indices[e]&&(this.macro_part_index_to_segment_item_indices[e]=[]),this.macro_part_index_to_segment_item_indices[e].push(s)}.bind(this);for(let t=i;!t.Is_At_End();){const o=Part.Command.Maybe_Valid_Value_From(t.Points());if(null!=o){const e=new Part.Command.Instance({index:this.micro_parts.length,value:o}),s=new Part.Command.Instance({index:this.macro_parts.length,value:o});s.Is_Open_Italic()?n|=Part.Style.ITALIC:s.Is_Close_Italic()?n&=~Part.Style.ITALIC:s.Is_Open_Bold()?n|=Part.Style.BOLD:s.Is_Close_Bold()?n&=~Part.Style.BOLD:s.Is_Open_Underline()?n|=Part.Style.UNDERLINE:s.Is_Close_Underline()?n&=~Part.Style.UNDERLINE:s.Is_Open_Small_Caps()?n|=Part.Style.SMALL_CAPS:s.Is_Close_Small_Caps()?n&=~Part.Style.SMALL_CAPS:s.Is_Open_Error()?n|=Part.Style.ERROR:s.Is_Close_Error()&&(n&=~Part.Style.ERROR),this.micro_parts.push(e),this.macro_parts.push(s),c(e),l(s),t=new Unicode.Iterator({text:t.Text(),index:t.Index()+o.length}),i=t}else{const o=t.Point(),m=t.Look_Forward_Point(),d=Part.Command.Maybe_Valid_Value_From(t.Look_Forward_Points()||"");if(s.Has_Letter(o)){const t=new Part.Letter.Instance({index:this.micro_parts.length,value:o,style:n});this.micro_parts.push(t),c(t),r=e.WORD}else if(s.Has_Marker(o)){const t=new Part.Marker.Instance({index:this.micro_parts.length,value:o,style:n});this.micro_parts.push(t),c(t),r=e.BREAK}else{const s=new Part.Point.Instance({index:this.micro_parts.length,value:o,style:n}),_=new Part.Point.Instance({index:this.macro_parts.length,value:o,style:n});this.micro_parts.push(s),c(s),r=e.POINT,null==a&&(a=t.Index()),this.macro_parts.push(_),l(_),i=t.Next()}if(r===e.WORD){if(null==m||null!=d||!s.Has_Letter(m)){null==a&&(a=t.Index());const e=t.Text().slice(i.Index(),t.Look_Forward_Index()),r=s.Has_Word(e)?Part.Status.GOOD:s.Has_Word_Error(e)?Part.Status.ERROR:Part.Status.UNKNOWN,_=new Part.Word.Instance({index:this.macro_parts.length,value:e,status:r,style:n});this.macro_parts.push(_),l(_),i=t.Next()}}else if(r===e.BREAK&&(null==m||null!=d||!s.Has_Marker(m))){null==a&&(a=t.Index());const e=t.Text().slice(i.Index(),t.Look_Forward_Index()),r=t.Index()===a?Dictionary.Boundary.START:t.Index()===_?Dictionary.Boundary.END:Dictionary.Boundary.MIDDLE,o=s.Has_Break(e,r)?Part.Status.GOOD:s.Has_Break_Error(e,r)?Part.Status.ERROR:Part.Status.UNKNOWN,m=new Part.Break.Instance({index:this.macro_parts.length,value:e,status:o,style:n});this.macro_parts.push(m);const c=Split.From(m);for(const t of c)l(t);i=t.Next()}t=t.Next()}}o.Item_Count()>0&&this.micro_segments.push(o),m.Item_Count()>0&&this.macro_segments.push(m)}Has_Micro_Part(t){return Utils.Assert(t>-1,"micro_part_index must be greater than -1."),t<this.Micro_Part_Count()}Micro_Part_Count(){return this.micro_parts.length}Micro_Part(t){return Utils.Assert(this.Has_Micro_Part(t),`Does not have micro_part at index ${t}.`),this.micro_parts[t]}Has_Macro_Part(t){return Utils.Assert(t>-1,"macro_part_index must be greater than -1."),t<this.Macro_Part_Count()}Macro_Part_Count(){return this.macro_parts.length}Macro_Part(t){return Utils.Assert(this.Has_Macro_Part(t),`Does not have macro_part at index ${t}.`),this.macro_parts[t]}Micro_Segment_Count(){return this.micro_segments.length}Micro_Segment(t){return Utils.Assert(t>-1,"micro_segment_index must be greater than -1."),Utils.Assert(t<this.Micro_Segment_Count(),"micro_segment_index must be less than micro_segment_count."),this.micro_segments[t]}Macro_Segment_Count(){return this.macro_segments.length}Macro_Segment(t){return Utils.Assert(t>-1,"macro_segment_index must be greater than -1."),Utils.Assert(t<this.Macro_Segment_Count(),"macro_segment_index must be less than macro_segment_count."),this.macro_segments[t]}Micro_Part_Segment_Item_Indices(t){Utils.Assert(this.Has_Micro_Part(t),`Does not have micro_part at index ${t}.`);const e=this.micro_part_index_to_segment_item_indices[t];return Object.isFrozen(e)||Object.freeze(e),e}Macro_Part_Segment_Item_Indices(t){Utils.Assert(this.Has_Macro_Part(t),`Does not have macro_part at index ${t}.`);const e=this.macro_part_index_to_segment_item_indices[t];return Object.isFrozen(e)||Object.freeze(e),e}Is_Centered(){return this.is_centered}Is_Indented(){return this.is_indented}}