import*as Utils from"../../../utils.js";import{Type}from"./type.js";export class Instance{constructor({segment_type:t,index:s}){this.segment_type=t,this.index=s,this.items=[]}Segment_Type(){return this.segment_type}Index(){return this.index}Item_Count(){return this.items.length}Has_Item(t){return this.items.indexOf(t)>-1}Has_Item_Index(t){return t>-1&&t<this.items.length}Item(t){return Utils.Assert(this.Has_Item_Index(t),`Does not have an item at index ${t}.`),this.items[t]}Item_Index(t){const s=this.items.indexOf(t);return Utils.Assert(s>-1,"Does not have item."),s}Items(){return Array.from(this.items)}Try_Add_Item(t){const s=this.Segment_Type();if(s===Type.MICRO){if(Utils.Assert(t.Is_Part()&&(t.Is_Point()||t.Is_Letter()||t.Is_Marker()||t.Is_Command()),"Can only add micro parts to a micro segment."),0===this.items.length)return this.items.push(t),!0;{const s=t,e=this.items[this.items.length-1];return s.Is_Point()?e.Is_Point()?(this.items.push(s),!0):!e.Is_Letter()&&(e.Is_Marker()?!!/\S+/.test(e.Value())&&(this.items.push(s),!0):e.Is_Command()?(this.items.push(s),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1)):s.Is_Letter()?!e.Is_Point()&&(e.Is_Letter()?(this.items.push(s),!0):e.Is_Marker()?!!/\S+/.test(e.Value())&&(this.items.push(s),!0):e.Is_Command()?(this.items.push(s),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1)):s.Is_Marker()||s.Is_Command()?e.Is_Point()||e.Is_Letter()?(this.items.push(s),!0):e.Is_Marker()?!!/\S+/.test(e.Value())&&(this.items.push(s),!0):e.Is_Command()?(this.items.push(s),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1):(Utils.Assert(!1,"Invalid part_type."),!1)}}if(s===Type.MACRO){if(Utils.Assert(t.Is_Part()&&(t.Is_Point()||t.Is_Word()||t.Is_Command())||t.Is_Split(),"Can only add macro parts to a macro segment."),0===this.items.length)return this.items.push(t),!0;{const s=this.items[this.items.length-1];if(t.Is_Part()){const e=t;if(e.Is_Point()){if(s.Is_Part()){const t=s;return t.Is_Point()?(this.items.push(e),!0):!t.Is_Word()&&(t.Is_Command()?(this.items.push(e),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1))}if(s.Is_Split()){return!!/\S+/.test(s.Value())&&(this.items.push(e),!0)}return Utils.Assert(!1,"Invalid previous_item_type."),!1}if(e.Is_Word()){if(s.Is_Part()){const t=s;return!t.Is_Point()&&(!t.Is_Word()&&(t.Is_Command()?(this.items.push(e),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1)))}if(s.Is_Split()){return!!/\S+/.test(s.Value())&&(this.items.push(e),!0)}return Utils.Assert(!1,"Invalid previous_item_type."),!1}if(e.Is_Command()){if(s.Is_Part()){const t=s;return t.Is_Point()||t.Is_Word()||t.Is_Command()?(this.items.push(e),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1)}if(s.Is_Split()){return!!/\S+/.test(s.Value())&&(this.items.push(e),!0)}return Utils.Assert(!1,"Invalid previous_item_type."),!1}return Utils.Assert(!1,"Invalid part_type."),!1}if(t.Is_Split()){const e=t;if(s.Is_Part()){const t=s;return t.Is_Point()||t.Is_Word()||t.Is_Command()?(this.items.push(e),!0):(Utils.Assert(!1,"Invalid previous_part_type."),!1)}if(s.Is_Split()){return!!/\S+/.test(s.Value())&&(this.items.push(e),!0)}return Utils.Assert(!1,"Invalid previous_item_type."),!1}return Utils.Assert(!1,"Unknown item_type."),!1}}return s===Type.MACRO_LEFT_TO_RIGHT||s===Type.MACRO_RIGHT_TO_LEFT?(Utils.Assert(t.Is_Part()&&(t.Is_Point()||t.Is_Word()||t.Is_Command())||t.Is_Split(),"Can only add macro parts to a macro segment."),this.items.push(t),!0):(Utils.Assert(!1,"Unknown segment_type."),!1)}Add_Item(t){const s=this.Try_Add_Item(t);Utils.Assert(!0===s,"Failed to add item.")}Value(){let t="";for(const s of this.items)t+=s.Value();return t}}