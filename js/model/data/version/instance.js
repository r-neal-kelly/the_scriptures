var __awaiter=this&&this.__awaiter||function(t,e,s,i){return new(s||(s=Promise))((function(n,r){function o(t){try{h(i.next(t))}catch(t){r(t)}}function a(t){try{h(i.throw(t))}catch(t){r(t)}}function h(t){var e;t.done?n(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(o,a)}h((i=i.apply(t,e||[])).next())}))};import*as Utils from"../../../utils.js";import*as Main_Compressors from"../../../compressor.js";import*as Entity from"../../entity.js";import*as Compressor from"../compressor.js";import*as Dictionary from"./dictionary.js";import*as Text from"./text.js";import*as File from"../file.js";export var Consts;!function(t){t.UNIQUE_PARTS_FILE_NAME="Unique_Parts.comp"}(Consts||(Consts={}));export var Symbol;!function(t){t.FILE_BREAK="\n~~~FILE_BREAK~~~\n"}(Symbol||(Symbol={}));export class Instance extends Entity.Instance{constructor({language:t,branch:e}){super(),this.language=t,this.name=e.name,this.path=`${t.Path()}/${e.name}`,this.compressor=null,this.dictionary=new Dictionary.Instance({version:this}),this.text=new Text.Instance({version:this}),this.files=[];for(let t=0,s=e.files.length;t<s;t+=1)this.files.push(new File.Instance({version:this,name:e.files[t],index:t}));this.Add_Dependencies([])}Language(){return this.language}Name(){return this.name}Path(){return this.path}Compressor({fetch_attempt_count:t,fetch_attempt_limit:e}={fetch_attempt_count:0,fetch_attempt_limit:3}){return __awaiter(this,void 0,void 0,(function*(){if(null!=this.compressor)return this.compressor;if(t<e){const s=yield fetch(Utils.Resolve_Path(`${this.Path()}/${Consts.UNIQUE_PARTS_FILE_NAME}`));return s.ok?(this.compressor=new Compressor.Instance({unique_parts:JSON.parse(Main_Compressors.LZSS_Decompress(yield s.text()))}),this.compressor):yield this.Compressor({fetch_attempt_count:t+1,fetch_attempt_limit:e})}return new Compressor.Instance({unique_parts:[]})}))}Dictionary(){return __awaiter(this,void 0,void 0,(function*(){return yield this.dictionary.Ready(),this.dictionary}))}Text(){return __awaiter(this,void 0,void 0,(function*(){return yield this.text.Ready(),this.text}))}File(t){for(const e of this.files)if(e.Name()===t)return e;return 0,this.files[0]}File_Count(){return this.files.length}File_At(t){return 0,0,this.files[t]}Files(){return Array.from(this.files)}}