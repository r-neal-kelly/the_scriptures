import*as Utils from"../../utils.js";import*as Unicode from"../../unicode.js";import*as Text from"../text.js";const LINE_PATH_TYPE=Text.Line.Path_Type.DEFAULT;export var Symbol;!function(t){t[t.NEWLINE=0]="NEWLINE",t[t.VERBATIM_OPEN=1]="VERBATIM_OPEN",t[t.VERBATIM_CLOSE=2]="VERBATIM_CLOSE",t[t._COUNT_=3]="_COUNT_"}(Symbol||(Symbol={}));export class Instance{constructor({unique_parts:t}){Utils.Assert(t.length<=Number.MAX_SAFE_INTEGER-Symbol._COUNT_,"There are too may unique parts in the index to compress."),this.indices={},this.values={};for(let o=0,e=t.length;o<e;o+=1){const e=o+Symbol._COUNT_;this.indices[t[o]]=e,this.values[e]=t[o]}}Compress_Dictionary({dictionary_value:t}){const o=String.fromCodePoint(0),e=String.fromCodePoint(1),i='"';let n="",s=!1,r=!1,c=0;for(let l=0,_=t.length;l<_;l+=1){const a=t[l];if(Utils.Assert(a!==o&&a!==e,"Cannot compress a dictionary that contains a code point of 0 or 1."),s){if("\\"===a&&l+1<_&&t[l+1]===i)l+=1;else if(a===i){const a=t.slice(c,l);this.indices.hasOwnProperty(a)?l+1<_&&","===t[l+1]?(r||(n+=o,r=!0),n+=String.fromCodePoint(this.indices[a]),l+=1):(r&&(n+=o,r=!1),n+=e,n+=String.fromCodePoint(this.indices[a])):(r&&(n+=o,r=!1),n+=i,n+=a,n+=i),s=!1,c=0}}else a===i?(s=!0,c=l+1):(r&&(n+=o,r=!1),n+=a)}return n}Decompress_Dictionary({dictionary_value:t}){const o=String.fromCodePoint(0),e=String.fromCodePoint(1),i='"';let n="",s=new Unicode.Iterator({text:t}),r=!1;for(;!s.Is_At_End();s=s.Next())r?s.Point()===o?r=!1:(n+=i,n+=this.values[s.Point().codePointAt(0)],n+=i,n+=","):s.Point()===o?r=!0:s.Point()===e?(s=s.Next(),n+=i,n+=this.values[s.Point().codePointAt(0)],n+=i):n+=s.Point();return n}Compress_File({dictionary:t,file_value:o}){const e=[],i=String.fromCodePoint(Symbol.NEWLINE),n=String.fromCodePoint(Symbol.VERBATIM_OPEN),s=String.fromCodePoint(Symbol.VERBATIM_CLOSE),r=new Text.Instance({dictionary:t,value:o});for(let t=0,o=r.Line_Count();t<o;t+=1){const c=r.Line(t);let l=!1;for(let t=0,o=c.Macro_Part_Count(LINE_PATH_TYPE);t<o;t+=1){const i=c.Macro_Part(t,LINE_PATH_TYPE),r=i.Value();if(this.indices.hasOwnProperty(r)){const n=String.fromCodePoint(this.indices[r]);i.Is_Word()?(e.push(n),l=!0):(" "===r&&l&&t+1<o&&c.Macro_Part(t+1,LINE_PATH_TYPE).Is_Word()||e.push(n),l=!1)}else e[e.length-1]===s?e.pop():e.push(n),e.push(r),e.push(s),l=!1}t<o-1&&e.push(i)}return e.join("")}Decompress_File({dictionary:t,file_value:o}){const e=[];let i=new Unicode.Iterator({text:o}),n=!1;for(;!i.Is_At_End();i=i.Next())if(i.Point().codePointAt(0)===Symbol.VERBATIM_OPEN){const t=i.Next();for(i=t;i.Point().codePointAt(0)!==Symbol.VERBATIM_CLOSE;)i=i.Next();e.push(t.Points().slice(0,i.Index()-t.Index())),n=!1}else if(i.Point().codePointAt(0)===Symbol.NEWLINE)e.push("\n"),n=!1;else{const o=this.values[i.Point().codePointAt(0)];t.Has_Word(o)||t.Has_Word_Error(o)?(n&&e.push(" "),e.push(o),n=!0):(e.push(o),n=!1)}return e.join("")}}