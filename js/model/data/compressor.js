import*as Utils from"../../utils.js";import*as Unicode from"../../unicode.js";import*as Text from"../text.js";const LINE_PATH_TYPE=Text.Line.Path_Type.DEFAULT;export var Symbol;!function(t){t[t.NEWLINE=0]="NEWLINE",t[t.VERBATIM_OPEN=1]="VERBATIM_OPEN",t[t.VERBATIM_CLOSE=2]="VERBATIM_CLOSE",t[t._COUNT_=3]="_COUNT_"}(Symbol||(Symbol={}));export class Instance{constructor({unique_parts:t}){Utils.Assert(t.length<=Number.MAX_SAFE_INTEGER-Symbol._COUNT_,"There are too may unique_parts to compress."),this.indices={},this.values={};for(let o=0,e=t.length;o<e;o+=1){const e=o+Symbol._COUNT_;this.indices[t[o]]=e,this.values[e]=t[o]}}Compress({value:t,dictionary:o}){const e=[],n=String.fromCodePoint(Symbol.NEWLINE),i=String.fromCodePoint(Symbol.VERBATIM_OPEN),s=String.fromCodePoint(Symbol.VERBATIM_CLOSE),r=new Text.Instance({dictionary:o,value:t});for(let t=0,o=r.Line_Count();t<o;t+=1){const c=r.Line(t);let P=!1;for(let t=0,o=c.Macro_Part_Count(LINE_PATH_TYPE);t<o;t+=1){const n=c.Macro_Part(t,LINE_PATH_TYPE),r=n.Value();if(this.indices.hasOwnProperty(r)){const i=String.fromCodePoint(this.indices[r]);n.Is_Word()?(e.push(i),P=!0):(" "===r&&P&&t+1<o&&c.Macro_Part(t+1,LINE_PATH_TYPE).Is_Word()||e.push(i),P=!1)}else e[e.length-1]===s?e.pop():e.push(i),e.push(r),e.push(s),P=!1}t<o-1&&e.push(n)}return e.join("")}Decompress({value:t,dictionary:o}){const e=[];let n=new Unicode.Iterator({text:t}),i=!1;for(;!n.Is_At_End();n=n.Next())if(n.Point().codePointAt(0)===Symbol.VERBATIM_OPEN){const t=n.Next();for(n=t;n.Point().codePointAt(0)!==Symbol.VERBATIM_CLOSE;)n=n.Next();e.push(t.Points().slice(0,n.Index()-t.Index())),i=!1}else if(n.Point().codePointAt(0)===Symbol.NEWLINE)e.push("\n"),i=!1;else{const t=this.values[n.Point().codePointAt(0)];o.Has_Word(t)||o.Has_Word_Error(t)?(i&&e.push(" "),e.push(t),i=!0):(e.push(t),i=!1)}return e.join("")}Compress_Dictionary(t){const o=String.fromCodePoint(0),e=String.fromCodePoint(1),n='"';let i="",s=!1,r=!1,c=0;for(let P=0,_=t.length;P<_;P+=1){const a=t[P];if(Utils.Assert(a!==o&&a!==e,"Cannot compress a dictionary that contains a code point of 0 or 1."),s){if("\\"===a&&P+1<_&&t[P+1]===n)P+=1;else if(a===n){const a=t.slice(c,P);this.indices.hasOwnProperty(a)?P+1<_&&","===t[P+1]?(r||(i+=o,r=!0),i+=String.fromCodePoint(this.indices[a]),P+=1):(r&&(i+=o,r=!1),i+=e,i+=String.fromCodePoint(this.indices[a])):(r&&(i+=o,r=!1),i+=n,i+=a,i+=n),s=!1,c=0}}else a===n?(s=!0,c=P+1):(r&&(i+=o,r=!1),i+=a)}return i}Decompress_Dictionary(t){const o=String.fromCodePoint(0),e=String.fromCodePoint(1),n='"';let i="",s=new Unicode.Iterator({text:t}),r=!1;for(;!s.Is_At_End();s=s.Next())r?s.Point()===o?r=!1:(i+=n,i+=this.values[s.Point().codePointAt(0)],i+=n,i+=","):s.Point()===o?r=!0:s.Point()===e?(s=s.Next(),i+=n,i+=this.values[s.Point().codePointAt(0)],i+=n):i+=s.Point();return i}}