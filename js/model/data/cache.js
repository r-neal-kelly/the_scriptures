var __awaiter=this&&this.__awaiter||function(t,n,e,i){return new(e||(e=Promise))((function(s,o){function r(t){try{a(i.next(t))}catch(t){o(t)}}function c(t){try{a(i.throw(t))}catch(t){o(t)}}function a(t){var n;t.done?s(t.value):(n=t.value,n instanceof e?n:new e((function(t){t(n)}))).then(r,c)}a((i=i.apply(t,n||[])).next())}))};import*as Utils from"../../utils.js";import*as Async from"../../async.js";import*as Compressor from"../../compressor.js";import*as Consts from"./consts.js";import*as Info from"./info.js";export class Instance extends Async.Instance{constructor(){super(),this.info=null,this.Add_Dependencies([])}Info(t=!1){return __awaiter(this,void 0,void 0,(function*(){if(t&&(this.info=null),null!=this.info)return this.info;{const t=yield this.Text(Consts.INFO_PATH);return null!=t&&(this.info=new Info.Instance({json:Compressor.LZSS_Decompress(t)})),this.info}}))}Text(t,{fetch_attempt_count:n,fetch_attempt_limit:e}={fetch_attempt_count:0,fetch_attempt_limit:10}){return __awaiter(this,void 0,void 0,(function*(){if(n<e){const i=yield fetch(Utils.Resolve_Path(t));return i.ok?yield i.text():this.Text(t,{fetch_attempt_count:n+1,fetch_attempt_limit:e})}return null}))}}