var __awaiter=this&&this.__awaiter||function(e,a,s,n){return new(s||(s=Promise))((function(o,t){function r(e){try{y(n.next(e))}catch(e){t(e)}}function i(e){try{y(n.throw(e))}catch(e){t(e)}}function y(e){var a;e.done?o(e.value):(a=e.value,a instanceof s?a:new s((function(e){e(a)}))).then(r,i)}y((n=n.apply(e,a||[])).next())}))};import*as Utils from"../../utils.js";import*as Async from"../../async.js";import*as Name_Sorter from"../name_sorter.js";import{Type}from"./type.js";import{Info}from"./info.js";import*as Book from"./book.js";export class Instance extends Async.Instance{constructor(){super(),this.name="data",this.path=this.name,this.books_path=`${this.path}/Books`,this.info=null,this.books=[],this.Add_Dependencies([])}Name(){return this.name}Path(){return this.path}Books_Path(){return this.books_path}Info(){return Utils.Assert(this.Is_Ready(),"Not ready."),Utils.Assert(null!=this.info,"info is null!"),this.info}Book(e){Utils.Assert(this.Is_Ready(),"Not ready.");for(const a of this.books)if(a.Name()===e)return a;return Utils.Assert(!1,"Invalid book_name."),this.books[0]}Book_Count(){return Utils.Assert(this.Is_Ready(),"Not ready."),this.books.length}Book_At(e){return Utils.Assert(this.Is_Ready(),"Not ready."),Utils.Assert(e>-1,"book_index must be greater than -1."),Utils.Assert(e<this.Book_Count(),"book_index must be less than book_count."),this.books[e]}Books(){return Utils.Assert(this.Is_Ready(),"Not ready."),Array.from(this.books)}Names(e){return Utils.Assert(this.Is_Ready(),"Not ready."),1===e.length?(Utils.Assert(null==e[0].Name(),"Unusable name.\n                A query length of 1 only requires a type."),e[0].Type()===Type.BOOKS||e[0].Type()===Type.BOOK?this.Book_Names():e[0].Type()===Type.LANGUAGES||e[0].Type()===Type.LANGUAGE?this.Language_Names():e[0].Type()===Type.VERSIONS||e[0].Type()===Type.VERSION?this.Version_Names():(Utils.Assert(!1,"Invalid type.\n                    A query length of 1 can only gather Books, Languages, or Versions."),[])):2===e.length?(Utils.Assert(null!=e[0].Name(),"Missing name.\n                A query length of 2 requires a name at index 0."),Utils.Assert(null==e[1].Name(),"Unusable name.\n                A query length of 2 only requires a type at index 1."),e[0].Type()!==Type.BOOKS&&e[0].Type()!==Type.BOOK||e[1].Type()!==Type.LANGUAGES&&e[1].Type()!==Type.LANGUAGE?e[0].Type()!==Type.BOOKS&&e[0].Type()!==Type.BOOK||e[1].Type()!==Type.VERSIONS&&e[1].Type()!==Type.VERSION?e[0].Type()!==Type.LANGUAGES&&e[0].Type()!==Type.LANGUAGE||e[1].Type()!==Type.BOOKS&&e[1].Type()!==Type.BOOK?e[0].Type()!==Type.LANGUAGES&&e[0].Type()!==Type.LANGUAGE||e[1].Type()!==Type.VERSIONS&&e[1].Type()!==Type.VERSION?e[0].Type()!==Type.VERSIONS&&e[0].Type()!==Type.VERSION||e[1].Type()!==Type.BOOKS&&e[1].Type()!==Type.BOOK?e[0].Type()!==Type.VERSIONS&&e[0].Type()!==Type.VERSION||e[1].Type()!==Type.LANGUAGES&&e[1].Type()!==Type.LANGUAGE?(Utils.Assert(!1,"Invalid type.\n                    A query length of 2 can only gather a combination of Books, Languages, or Versions.\n                    Each index in the query must have a unique type, and cannot contain repeats."),[]):this.Version_Language_Names({version_name:e[0].Name()}):this.Version_Book_Names({version_name:e[0].Name()}):this.Language_Version_Names({language_name:e[0].Name()}):this.Language_Book_Names({language_name:e[0].Name()}):this.Book_Version_Names({book_name:e[0].Name()}):this.Book_Language_Names({book_name:e[0].Name()})):3===e.length?(Utils.Assert(null!=e[0].Name()&&null!=e[1].Name(),"Missing name.\n                A query length of 3 requires a name for indices 0 and 1."),Utils.Assert(null==e[2].Name(),"Unusable name.\n                A query length of 3 only requires a type at index 2."),e[0].Type()!==Type.BOOKS&&e[0].Type()!==Type.BOOK||e[1].Type()!==Type.LANGUAGES&&e[1].Type()!==Type.LANGUAGE||e[2].Type()!==Type.VERSIONS&&e[2].Type()!==Type.VERSION?e[0].Type()!==Type.BOOKS&&e[0].Type()!==Type.BOOK||e[1].Type()!==Type.VERSIONS&&e[1].Type()!==Type.VERSION||e[2].Type()!==Type.LANGUAGES&&e[2].Type()!==Type.LANGUAGE?e[0].Type()!==Type.LANGUAGES&&e[0].Type()!==Type.LANGUAGE||e[1].Type()!==Type.BOOKS&&e[1].Type()!==Type.BOOK||e[2].Type()!==Type.VERSIONS&&e[2].Type()!==Type.VERSION?e[0].Type()!==Type.LANGUAGES&&e[0].Type()!==Type.LANGUAGE||e[1].Type()!==Type.VERSIONS&&e[1].Type()!==Type.VERSION||e[2].Type()!==Type.BOOKS&&e[2].Type()!==Type.BOOK?e[0].Type()!==Type.VERSIONS&&e[0].Type()!==Type.VERSION||e[1].Type()!==Type.BOOKS&&e[1].Type()!==Type.BOOK||e[2].Type()!==Type.LANGUAGES&&e[2].Type()!==Type.LANGUAGE?e[0].Type()!==Type.VERSIONS&&e[0].Type()!==Type.VERSION||e[1].Type()!==Type.LANGUAGES&&e[1].Type()!==Type.LANGUAGE||e[2].Type()!==Type.BOOKS&&e[2].Type()!==Type.BOOK?(Utils.Assert(!1,"Invalid type.\n                    A query length of 3 can only gather a combination of Books, Languages, or Versions.\n                    Each index in the query must have a unique type, and cannot contain repeats."),[]):this.Version_Language_Book_Names({version_name:e[0].Name(),language_name:e[1].Name()}):this.Version_Book_Language_Names({version_name:e[0].Name(),book_name:e[1].Name()}):this.Language_Version_Book_Names({language_name:e[0].Name(),version_name:e[1].Name()}):this.Language_Book_Version_Names({language_name:e[0].Name(),book_name:e[1].Name()}):this.Book_Version_Language_Names({book_name:e[0].Name(),version_name:e[1].Name()}):this.Book_Language_Version_Names({book_name:e[0].Name(),language_name:e[1].Name()})):4===e.length?(Utils.Assert(null!=e[0].Name()&&null!=e[1].Name()&&null!=e[2].Name(),"Missing name.\n                A query length of 4 must have a name for indices 0, 1, and 2."),Utils.Assert(null==e[3].Name(),"Unusable name.\n                A query length of 4 only requires a type at index 3."),Utils.Assert(e[3].Type()===Type.FILES||e[3].Type()===Type.FILE,"Invalid type.\n                A query length of 4 requires index 3 to have a type indicated Files."),e[0].Type()!==Type.BOOKS&&e[0].Type()!==Type.BOOK||e[1].Type()!==Type.LANGUAGES&&e[1].Type()!==Type.LANGUAGE||e[2].Type()!==Type.VERSIONS&&e[2].Type()!==Type.VERSION?e[0].Type()!==Type.BOOKS&&e[0].Type()!==Type.BOOK||e[1].Type()!==Type.VERSIONS&&e[1].Type()!==Type.VERSION||e[2].Type()!==Type.LANGUAGES&&e[2].Type()!==Type.LANGUAGE?e[0].Type()!==Type.LANGUAGES&&e[0].Type()!==Type.LANGUAGE||e[1].Type()!==Type.BOOKS&&e[1].Type()!==Type.BOOK||e[2].Type()!==Type.VERSIONS&&e[2].Type()!==Type.VERSION?e[0].Type()!==Type.LANGUAGES&&e[0].Type()!==Type.LANGUAGE||e[1].Type()!==Type.VERSIONS&&e[1].Type()!==Type.VERSION||e[2].Type()!==Type.BOOKS&&e[2].Type()!==Type.BOOK?e[0].Type()!==Type.VERSIONS&&e[0].Type()!==Type.VERSION||e[1].Type()!==Type.BOOKS&&e[1].Type()!==Type.BOOK||e[2].Type()!==Type.LANGUAGES&&e[2].Type()!==Type.LANGUAGE?e[0].Type()!==Type.VERSIONS&&e[0].Type()!==Type.VERSION||e[1].Type()!==Type.LANGUAGES&&e[1].Type()!==Type.LANGUAGE||e[2].Type()!==Type.BOOKS&&e[2].Type()!==Type.BOOK?(Utils.Assert(!1,"Invalid type.\n                    A query length of 4 must have a combination of Books, Languages, Versions, and Files.\n                    Each index in the query must have a unique type, and cannot contain repeats.\n                    The last index must indicate Files."),[]):this.File_Names({book_name:e[2].Name(),language_name:e[1].Name(),version_name:e[0].Name()}):this.File_Names({book_name:e[1].Name(),language_name:e[2].Name(),version_name:e[0].Name()}):this.File_Names({book_name:e[2].Name(),language_name:e[0].Name(),version_name:e[1].Name()}):this.File_Names({book_name:e[1].Name(),language_name:e[0].Name(),version_name:e[2].Name()}):this.File_Names({book_name:e[0].Name(),language_name:e[2].Name(),version_name:e[1].Name()}):this.File_Names({book_name:e[0].Name(),language_name:e[1].Name(),version_name:e[2].Name()})):(Utils.Assert(!1,"Invalid query length.\n                A query must have a length from 1 to 4."),[])}Book_Names(){return Utils.Assert(this.Is_Ready(),"Not ready."),this.Info().Unique_Book_Names()}Book_Language_Names({book_name:e}){Utils.Assert(this.Is_Ready(),"Not ready.");const a=new Set;for(const s of this.Books())if(s.Name()===e){for(const e of s.Languages())a.add(e.Name());break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.LANGUAGES,a)}Book_Version_Names({book_name:e}){Utils.Assert(this.Is_Ready(),"Not ready.");const a=new Set;for(const s of this.Books())if(s.Name()===e){for(const e of s.Languages())for(const s of e.Versions())a.add(s.Name());break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.VERSIONS,a)}Book_Language_Version_Names({book_name:e,language_name:a}){Utils.Assert(this.Is_Ready(),"Not ready.");const s=new Set;for(const n of this.Books())if(n.Name()===e){for(const e of n.Languages())if(e.Name()===a){for(const a of e.Versions())s.add(a.Name());break}break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.VERSIONS,s)}Book_Version_Language_Names({book_name:e,version_name:a}){Utils.Assert(this.Is_Ready(),"Not ready.");const s=new Set;for(const n of this.Books())if(n.Name()===e){for(const e of n.Languages())for(const n of e.Versions())if(n.Name()===a){s.add(e.Name());break}break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.LANGUAGES,s)}Language_Names(){return Utils.Assert(this.Is_Ready(),"Not ready."),this.Info().Unique_Language_Names()}Language_Book_Names({language_name:e}){Utils.Assert(this.Is_Ready(),"Not ready.");const a=new Set;for(const s of this.Books())for(const n of s.Languages())if(n.Name()===e){a.add(s.Name());break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.BOOKS,a)}Language_Version_Names({language_name:e}){Utils.Assert(this.Is_Ready(),"Not ready.");const a=new Set;for(const s of this.Books())for(const n of s.Languages())if(n.Name()===e){for(const e of n.Versions())a.add(e.Name());break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.VERSIONS,a)}Language_Book_Version_Names({language_name:e,book_name:a}){Utils.Assert(this.Is_Ready(),"Not ready.");const s=new Set;for(const n of this.Books())if(n.Name()===a){for(const a of n.Languages())if(a.Name()===e){for(const e of a.Versions())s.add(e.Name());break}break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.VERSIONS,s)}Language_Version_Book_Names({language_name:e,version_name:a}){Utils.Assert(this.Is_Ready(),"Not ready.");const s=new Set;for(const n of this.Books())for(const o of n.Languages())if(o.Name()===e){for(const e of o.Versions())if(e.Name()===a){s.add(n.Name());break}break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.BOOKS,s)}Version_Names(){return Utils.Assert(this.Is_Ready(),"Not ready."),this.Info().Unique_Version_Names()}Version_Book_Names({version_name:e}){Utils.Assert(this.Is_Ready(),"Not ready.");const a=new Set;for(const s of this.Books())for(const n of s.Languages())for(const o of n.Versions())if(o.Name()===e){a.add(s.Name());break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.BOOKS,a)}Version_Language_Names({version_name:e}){Utils.Assert(this.Is_Ready(),"Not ready.");const a=new Set;for(const s of this.Books())for(const n of s.Languages())for(const s of n.Versions())if(s.Name()===e){a.add(n.Name());break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.LANGUAGES,a)}Version_Book_Language_Names({version_name:e,book_name:a}){Utils.Assert(this.Is_Ready(),"Not ready.");const s=new Set;for(const n of this.Books())if(n.Name()===a){for(const a of n.Languages())for(const n of a.Versions())if(n.Name()===e){s.add(a.Name());break}break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.LANGUAGES,s)}Version_Language_Book_Names({version_name:e,language_name:a}){Utils.Assert(this.Is_Ready(),"Not ready.");const s=new Set;for(const n of this.Books())for(const o of n.Languages())if(o.Name()===a){for(const a of o.Versions())if(a.Name()===e){s.add(n.Name());break}break}return Name_Sorter.Singleton().With_Set(Name_Sorter.Type.BOOKS,s)}Versions({book_names:e=null,language_names:a=null,version_names:s=null}){Utils.Assert(this.Is_Ready(),"Not ready.");const n=[];null==e&&(e=this.Book_Names()),null==a&&(a=this.Language_Names()),null==s&&(s=this.Version_Names());for(const o of this.Books())if(e.includes(o.Name()))for(const e of o.Languages())if(a.includes(e.Name()))for(const a of e.Versions())s.includes(a.Name())&&n.push(a);return n}Files({book_name:e,language_name:a,version_name:s}){return Utils.Assert(this.Is_Ready(),"Not ready."),this.Book(e).Language(a).Version(s).Files()}File({book_name:e,language_name:a,version_name:s,file_name:n}){return Utils.Assert(this.Is_Ready(),"Not ready."),this.Book(e).Language(a).Version(s).File(n)}File_Names({book_name:e,language_name:a,version_name:s}){return Utils.Assert(this.Is_Ready(),"Not ready."),this.Files({book_name:e,language_name:a,version_name:s}).map((function(e){return e.Name()}))}After_Dependencies_Are_Ready(){return __awaiter(this,void 0,void 0,(function*(){const e=yield fetch(Utils.Resolve_Path(`${this.Path()}/Info.json`));if(e.ok){this.info=new Info({json:yield e.text()});for(const e of this.info.Tree().books)this.books.push(new Book.Instance({data:this,branch:e}))}else this.info=new Info({}),this.info.Freeze()}))}}const SINGLETON=new Instance;export function Singleton(){return SINGLETON}