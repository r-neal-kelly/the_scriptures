import*as Utils from"../../../utils.js";import*as Entity from"../../entity.js";import*as Text from"../../text.js";import*as Segment from"./segment.js";const LINE_PATH_TYPE=Text.Line.Path_Type.DEFAULT;export class Instance extends Entity.Instance{static Min_Segment_Count(){return Instance.min_segment_count}static Set_Min_Segment_Count(e){Utils.Assert(e>=0,"min_segment_count must be greater than or equal to 0."),Instance.min_segment_count=e}constructor({buffer:e,index:t,result:n}){if(super(),this.buffer=e,this.index=t,this.result=n,this.segments=[],null==n)Utils.Assert(null==e,"buffer must be null."),Utils.Assert(null==t,"index must be null.");else if(Utils.Assert(null!=e,"buffer must not be null."),Utils.Assert(null!=t&&t>-1,"index must not be null, and must be greater than -1."),""===n.Line().Value(LINE_PATH_TYPE)){const e=new Text.Segment.Instance({segment_type:Text.Segment.Type.MICRO,index:0});e.Add_Item(new Text.Part.Instance({part_type:Text.Part.Type.POINT,index:0,value:"Â ",status:Text.Part.Status.GOOD,style:Text.Part.Style._NONE_,language:null})),this.segments.push(new Segment.Instance({line:this,index:0,text:e}))}else{for(let e=0,t=n.Line().Macro_Segment_Count(LINE_PATH_TYPE);e<t;e+=1)this.segments.push(new Segment.Instance({line:this,index:e,text:n.Line().Macro_Segment(e,LINE_PATH_TYPE)}));for(let e=0,t=n.Match_Count();e<t;e+=1){const t=n.Match(e),i=t.First_Part_Index(),s=t.First_Part_First_Unit_Index(),_=t.Last_Part_End_Unit_Index(),l=t.Last_Part_Index();for(let e=i,r=t.End_Part_Index();e<r;e+=1){const t=n.Line().Macro_Part_Segment_Item_Indices(e,LINE_PATH_TYPE);if(e===i&&e===l){let e=!1;for(let i=0,l=t.length;i<l;i+=1){const{segment_index:r,item_index:u}=t[i],m=n.Line().Macro_Segment(r,LINE_PATH_TYPE).Item(u);if(m.Is_Part())Utils.Assert(1===l,"A part item in segment was found split between segments!"),this.Segment_At(r).Item_At(u).Highlight({first_unit_index:s,end_unit_index:_});else{const t=m,n=t.End_Unit_Index();if(e){if(_<=n){this.Segment_At(r).Item_At(u).Highlight({first_unit_index:0,end_unit_index:_-t.First_Unit_Index()});break}this.Segment_At(r).Item_At(u).Highlight({first_unit_index:0,end_unit_index:t.Value().length})}else if(s<n){if(e=!0,_<=n){this.Segment_At(r).Item_At(u).Highlight({first_unit_index:s-t.First_Unit_Index(),end_unit_index:_-t.First_Unit_Index()});break}this.Segment_At(r).Item_At(u).Highlight({first_unit_index:s-t.First_Unit_Index(),end_unit_index:t.Value().length})}}}}else if(e===i){let e=!1;for(let i=0,_=t.length;i<_;i+=1){const{segment_index:l,item_index:r}=t[i],u=n.Line().Macro_Segment(l,LINE_PATH_TYPE).Item(r);if(u.Is_Part())Utils.Assert(1===_,"A part item in segment was found split between segments!"),this.Segment_At(l).Item_At(r).Highlight({first_unit_index:s,end_unit_index:u.Value().length});else{const t=u,n=t.End_Unit_Index();e?this.Segment_At(l).Item_At(r).Highlight({first_unit_index:0,end_unit_index:t.Value().length}):s<n&&(e=!0,this.Segment_At(l).Item_At(r).Highlight({first_unit_index:s-t.First_Unit_Index(),end_unit_index:t.Value().length}))}}}else if(e===l)for(let e=0,i=t.length;e<i;e+=1){const{segment_index:s,item_index:l}=t[e],r=n.Line().Macro_Segment(s,LINE_PATH_TYPE).Item(l);if(r.Is_Part())Utils.Assert(1===i,"A part item in segment was found split between segments!"),this.Segment_At(s).Item_At(l).Highlight({first_unit_index:0,end_unit_index:_});else{const e=r;if(_<=e.End_Unit_Index()){this.Segment_At(s).Item_At(l).Highlight({first_unit_index:0,end_unit_index:_-e.First_Unit_Index()});break}this.Segment_At(s).Item_At(l).Highlight({first_unit_index:0,end_unit_index:e.Value().length})}}else for(let e=0,i=t.length;e<i;e+=1){const{segment_index:i,item_index:s}=t[e],_=n.Line().Macro_Segment(i,LINE_PATH_TYPE).Item(s);this.Segment_At(i).Item_At(s).Highlight({first_unit_index:0,end_unit_index:_.Value().length})}}}}this.Add_Dependencies(this.segments)}Buffer(){return Utils.Assert(null!=this.buffer,"Doesn't have buffer."),this.buffer}Index(){return Utils.Assert(null!=this.index,"Doesn't have an index."),this.index}Result(){return Utils.Assert(null!=this.result,"Doesn't have result."),this.result}Value(){return this.Result().Line().Value(LINE_PATH_TYPE)}Segment_Count(){return this.segments.length}Segment_At(e){return Utils.Assert(e>-1,`segment_index (${e}) must be greater than -1.`),e<this.Segment_Count()?this.segments[e]:Instance.blank_segment}Is_Blank(){return null==this.result}Is_New_Line(){return""===this.Result().Line().Value(LINE_PATH_TYPE)}Is_Centered(){return this.Result().Line().Is_Centered(LINE_PATH_TYPE)}}Instance.min_segment_count=70,Instance.blank_segment=new Segment.Instance({line:null,index:null,text:null});